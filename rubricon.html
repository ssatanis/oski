<!DOCTYPE html>
<html data-wf-domain="tenet-template.webflow.io" data-wf-page="683d91777124b040c4a5b5cd" data-wf-site="683d91777124b040c4a5b5db" lang="en">
<head>
    <meta charset="utf-8">
    <title>Rubricon | Oski</title>
    <meta content="Transform OSCE rubrics into AI-ready prompts with intelligent OCR processing and automated YAML generation." name="description">
    <meta content="Rubricon - Oski" property="og:title">
    <meta content="Transform OSCE rubrics into AI-ready prompts with intelligent OCR processing and automated YAML generation." property="og:description">
    <meta content="images/OskiPreview.png" property="og:image">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    
    <!-- Supabase Authentication -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- Oski CSS Framework -->
    <link href="https://cdn.prod.website-files.com/683d91777124b040c4a5b5db/css/tenet-template.webflow.shared.40365d26e.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com" rel="preconnect">
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
    <script src="js/1.6.26-webfont.js" type="text/javascript"></script>
    <script type="text/javascript">WebFont.load({  google: {    families: ["Geist:100,200,300,regular,500,600,700,800,900","Prata:regular"]  }});</script>
    <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>

    <!-- Dynamic Favicon -->
    <script>
    function setFavicon() {
      const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const favicon = document.querySelector('link[rel="shortcut icon"]') || document.createElement('link');
      favicon.rel = 'shortcut icon';
      favicon.type = 'image/svg+xml';
      favicon.href = isDarkMode ? 'favicons/White.svg' : 'favicons/Black.svg';
      if (!document.querySelector('link[rel="shortcut icon"]')) {
        document.head.appendChild(favicon);
      }
    }
    setFavicon();
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', setFavicon);
    </script>

    <link href="favicons/683d91777124b040c4a5b5db-683d91777124b040c4a5b63e_logo.png" rel="apple-touch-icon">
    
    <style>
        /* Hide Webflow badge */
        .w-webflow-badge {
            display: none !important;
        }

        /* Rubricon Specific Styles - Beautiful White with Animated Rainbow Gradient */
        .promptgen-section {
            padding: 120px 0 20px;
            background: linear-gradient(135deg, #ffffff 0%, #ffffff 100%);
            min-height: calc(100vh - 200px);
            position: relative;
            overflow: hidden;
        }

        /* Remove the rainbow line */
        .promptgen-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                #ff6b6b 0%, 
                #4ecdc4 14%, 
                #45b7d1 28%, 
                #96ceb4 42%, 
                #ffeaa7 56%, 
                #fab1a0 70%, 
                #fd79a8 84%, 
                #fdcb6e 100%
            );
            background-size: 200% 100%;
            animation: rainbowMove 8s ease-in-out infinite;
            opacity: 0.8;
            z-index: 1;
            display: none;
        }

        /* Subtle animated gradient background for depth */
        .promptgen-section::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(255, 107, 107, 0.02) 0%,
                rgba(78, 205, 196, 0.02) 25%,
                rgba(69, 183, 209, 0.02) 50%,
                rgba(150, 206, 180, 0.02) 75%,
                rgba(255, 234, 167, 0.02) 100%
            );
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            pointer-events: none;
            z-index: 0;
        }

        /* Ensure content appears above the gradient */
        .promptgen-container {
            position: relative;
            z-index: 2;
        }

        @keyframes rainbowMove {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Fix footer and navigation link styling - Remove underlines but keep bold */
        .footer a, .footer .button-first-line {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        .footer a:hover, .footer .button-first-line:hover {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        /* Ensure Navigation and Useful Links sections have no underlines but stay bold */
        .navigation-grid a {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        .navigation-grid a:hover {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        /* Override any conflicting styles */
        .footer .button-line-flex div {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        /* Remove underlines from contact links and keep normal weight */
        .footer .title-small a {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: normal !important;
        }

        .footer .title-small a:hover {
            text-decoration: none !important;
            border-bottom: none !important;
            opacity: 0.8;
        }

        /* Header navigation link styling */
        .navbar-link {
            text-decoration: none !important;
            border-bottom: none !important;
        }

        .navbar-link:hover {
            text-decoration: none !important;
            border-bottom: none !important;
        }

        /* Header logo normal size */
        .logotype {
            width: 100px !important;
            height: auto !important;
        }

        /* Perfect adaptive footer system */
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .promptgen-section {
            flex: 1;
            padding-bottom: 40px; /* Reduced gap to footer */
            transition: padding-bottom 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ============================================ */
        /* RUBRICON DASHBOARD - OSKI DESIGN LANGUAGE */
        /* ============================================ */
        
        /* Dashboard Container */
        #dashboardSection {
            display: none;
            opacity: 0;
            transform: translateY(40px) scale(0.98);
            transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #dashboardSection.visible {
            display: block;
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        /* Criteria Container with Enhanced Layout */
        #criteriaContainer {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 30px 0;
        }
        
        /* Individual Rubric Sections */
        .rubric-section {
            background: #ffffff;
            border-radius: 20px;
            border: 1px solid #f1f3f4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            padding: 30px;
            margin-bottom: 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slideUpIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(30px);
        }
        
        .rubric-section:nth-child(1) { animation-delay: 0.1s; }
        .rubric-section:nth-child(2) { animation-delay: 0.2s; }
        .rubric-section:nth-child(3) { animation-delay: 0.3s; }
        .rubric-section:nth-child(4) { animation-delay: 0.4s; }
        .rubric-section:nth-child(5) { animation-delay: 0.5s; }
        
        @keyframes slideUpIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .rubric-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #000000, #374151);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .rubric-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12), 0 4px 8px rgba(0, 0, 0, 0.08);
        }
        
        .rubric-section:hover::before {
            opacity: 1;
        }
        
        /* Section Header */
        .section-header-editable {
            margin-bottom: 25px;
        }
        
        .section-title-row {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 0;
            flex-wrap: wrap;
        }
        
        .section-name-input {
            font-size: 1.4rem;
            font-weight: 700;
            color: #1f2937;
            border: 2px solid transparent;
            background: transparent;
            padding: 12px 16px;
            border-radius: 12px;
            flex: 1;
            min-width: 300px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
        }
        
        .section-name-input:focus {
            border-color: #000000;
            background: #f9fafb;
            outline: none;
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .section-name-input:hover {
            background: #f9fafb;
        }
        
        .section-points {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f9fafb;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        .section-points:hover {
            border-color: #d1d5db;
            background: #f3f4f6;
        }
        
        .section-points label {
            font-weight: 600;
            color: #374151;
            margin: 0;
            font-size: 0.9rem;
        }
        
        .section-max-points {
            width: 70px;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 8px 12px;
            text-align: center;
            background: #ffffff;
            font-weight: 600;
            color: #1f2937;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        .section-max-points:focus {
            border-color: #000000;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
        }
        
        /* Items Container */
        .section-items {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* Individual Rubric Items */
        .rubric-item {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .rubric-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #6b7280, #9ca3af);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .rubric-item:hover {
            background: #ffffff;
            border-color: #d1d5db;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .rubric-item:hover::before {
            opacity: 1;
        }
        
        /* Item Header */
        .item-header {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .item-number {
            font-weight: 700;
            color: #374151;
            min-width: 30px;
            background: #ffffff;
            padding: 6px 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e5e7eb;
            font-family: "Geist", sans-serif;
        }
        
        .item-content {
            flex: 1;
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .item-description {
            flex: 1;
            min-width: 250px;
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 14px 16px;
            font-size: 1rem;
            background: #ffffff;
            color: #1f2937;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
            font-weight: 500;
        }
        
        .item-description:focus {
            border-color: #000000;
            outline: none;
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .item-description:hover {
            border-color: #d1d5db;
        }
        
        .item-points-container {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }
        
        .item-points-container label {
            font-weight: 600;
            color: #374151;
            margin: 0;
            font-size: 0.85rem;
            font-family: "Geist", sans-serif;
        }
        
        .item-points {
            width: 55px;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 6px 8px;
            text-align: center;
            background: #f9fafb;
            font-weight: 600;
            color: #1f2937;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        .item-points:focus {
            border-color: #000000;
            outline: none;
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
        }
        
        /* Examples Section */
        .item-examples {
            margin-left: 46px;
            margin-top: 16px;
        }
        
        .item-examples label {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
            margin-bottom: 8px;
            display: block;
            font-family: "Geist", sans-serif;
        }
        
        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        
        .example-item {
            display: flex;
            gap: 12px;
            align-items: center;
            animation: fadeInUp 0.3s ease forwards;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .example-item input {
            flex: 1;
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 0.9rem;
            background: #ffffff;
            color: #374151;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
        }
        
        .example-item input:focus {
            border-color: #6b7280;
            outline: none;
            box-shadow: 0 0 0 3px rgba(107, 114, 128, 0.1);
            transform: translateY(-1px);
        }
        
        .example-item input:hover {
            border-color: #d1d5db;
            background: #f9fafb;
        }
        
        /* Buttons - Oski Style */
        .remove-section-btn,
        .remove-item-btn,
        .remove-example {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #ffffff;
            border: none;
            border-radius: 10px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            font-family: "Geist", sans-serif;
        }
        
        .remove-section-btn::before,
        .remove-item-btn::before,
        .remove-example::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .remove-section-btn:hover::before,
        .remove-item-btn:hover::before,
        .remove-example:hover::before {
            left: 100%;
        }
        
        .remove-section-btn:hover,
        .remove-item-btn:hover,
        .remove-example:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
        }
        
        .add-item-btn,
        .add-example-btn,
        .add-section-btn {
            background: linear-gradient(135deg, #000000, #374151);
            color: #ffffff;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 12px;
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: "Geist", sans-serif;
        }
        
        .add-item-btn::before,
        .add-example-btn::before,
        .add-section-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .add-item-btn:hover::before,
        .add-example-btn:hover::before,
        .add-section-btn:hover::before {
            left: 100%;
        }
        
        .add-item-btn:hover,
        .add-example-btn:hover,
        .add-section-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .add-section-btn {
            width: 100%;
            font-size: 1.1rem;
            padding: 18px 24px;
            justify-content: center;
            margin-top: 30px;
            border-radius: 16px;
        }
        
        /* Form Elements Consistency */
        #systemMessage,
        #userMessagePreamble,
        #userMessagePreview {
            border: 2px solid transparent;
            border-radius: 16px;
            padding: 20px;
            font-size: 1rem;
            background: #f9fafb;
            color: #1f2937;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
            resize: vertical;
            min-height: 120px;
        }
        
        #systemMessage:focus,
        #userMessagePreamble:focus,
        #userMessagePreview:focus {
            border-color: #000000;
            background: #ffffff;
            outline: none;
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        /* Total Points Display */
        #totalPoints {
            font-size: 1.5rem;
            font-weight: 700;
            color: #000000;
            background: linear-gradient(135deg, #f9fafb, #ffffff);
            padding: 16px 24px;
            border-radius: 16px;
            border: 2px solid #e5e7eb;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .section-title-row {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .section-name-input {
                min-width: unset;
            }
            
            .item-content {
                flex-direction: column;
                align-items: stretch;
            }
            
            .item-description {
                min-width: unset;
            }
            
            .item-examples {
                margin-left: 0;
            }
            
            .rubric-section {
                padding: 20px;
            }
        }

        /* Enhanced section transitions based on state */
        .content-state-processing .promptgen-section {
            padding-bottom: 30px;
        }

        .content-state-dashboard .promptgen-section {
            padding-bottom: 20px;
        }

        .footer {
            margin-top: auto;
            background: #ffffff;
            /* Removed border-top line completely */
            transition: margin-top 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Dynamic footer positioning based on content state */
        .content-state-initial .footer {
            margin-top: auto;
        }

        .content-state-processing .footer {
            margin-top: 60px;
        }

        .content-state-dashboard .footer {
            margin-top: 80px;
        }

        /* GLOBAL BUTTON CENTERING - AFFECTS ALL PAGES */
        .button-flex {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            text-align: center !important;
            width: 100% !important;
        }

        .button-flex.center-mobile {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            text-align: center !important;
            width: 100% !important;
        }

        /* Ensure button containers are centered */
        .margin-30 .button-flex,
        .margin-40 .button-flex {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            text-align: center !important;
            width: 100% !important;
        }

        /* Center individual buttons */
        .button-first {
            margin: 0 auto !important;
            display: inline-block !important;
        }

        .promptgen-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .promptgen-header {
            text-align: center;
            margin-bottom: 60px;
            padding-top: 40px;
        }

        .breadcrumb-nav {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 20px;
            text-decoration: none;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }

        .breadcrumb-nav:hover {
            color: #000000;
        }

        .promptgen-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 1rem;
            font-family: "Geist", sans-serif;
        }

        .promptgen-subtitle {
            font-size: 1.1rem;
            color: #6b7280;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
            font-family: "Geist", sans-serif;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 40px;
            max-width: 800px;
            margin: 0 auto;
            margin-bottom: 20px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Smooth adaptive content transitions */
        .content-grid.file-uploaded {
            margin-bottom: 30px;
            transform: translateY(0);
        }

        .content-grid.processing-active {
            margin-bottom: 40px;
            transform: translateY(-10px);
        }

        .content-grid.dashboard-visible {
            margin-bottom: 50px;
            transform: translateY(-20px);
        }

        /* Upload Section - Enhanced with subtle rainbow accent */
        .upload-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 2px dashed #e5e7eb;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .upload-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1;
        }

        .upload-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.02), transparent);
            transition: left 0.6s ease;
        }

        .upload-card:hover::before {
            left: 100%;
        }

        .upload-card:hover::after,
        .upload-card.dragover::after {
            opacity: 1;
        }

        .upload-card.dragover {
            border-color: #000000;
            background: #ffffff;
            transform: scale(1.02);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15), 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .upload-content {
            text-align: center;
        }

        .upload-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
            padding: 20px;
            background: #f3f4f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .upload-card:hover .upload-icon {
            background: #000000;
            color: #ffffff;
            transform: scale(1.1);
        }

        .upload-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #000000;
            margin-bottom: 10px;
            font-family: "Geist", sans-serif;
        }

        .upload-description {
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 1rem;
            font-family: "Geist", sans-serif;
        }

        .file-input {
            display: none;
        }

        .upload-button {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 16px 32px;
            background: #000000;
            color: #ffffff;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            position: relative;
            overflow: hidden;
            font-family: "Geist", sans-serif;
        }

        .upload-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .upload-button:hover::before {
            left: 100%;
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        /* Processing Section */
        .processing-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            border: 1px solid #f1f3f4;
            opacity: 0;
            transform: translateY(30px) scale(0.98);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .processing-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            background-size: 200% 100%;
            opacity: 1;
        }

        .processing-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .processing-card.processed-success {
            background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
            border: 2px solid #10b981;
            box-shadow: 0 8px 30px rgba(16, 185, 129, 0.15);
            transform: translateY(0) scale(1);
        }

        .processing-card.processed-success::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
            opacity: 1;
        }

        /* Process button success state */
        .process-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .process-button.success:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
        }

        /* Progress indicator */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin: 2rem 0;
            padding: 0 1rem;
            position: relative;
        }

        .progress-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: #6b7280;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            position: relative;
            flex: 1;
            z-index: 2;
        }

        .progress-step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 16px;
            left: 50%;
            width: 100%;
            height: 2px;
            background: #e5e7eb;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .progress-step.active {
            color: #3b82f6;
            font-weight: 600;
        }

        .progress-step.completed {
            color: #10b981;
            font-weight: 600;
        }

        .progress-step.completed:not(:last-child)::after {
            background: #10b981;
        }

        .progress-step.active:not(:last-child)::after {
            background: linear-gradient(90deg, #3b82f6 50%, #e5e7eb 50%);
        }

        .progress-step-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            z-index: 3;
        }

        .progress-step.active .progress-step-icon {
            background: #3b82f6;
            color: white;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
            animation: pulse 2s infinite;
        }

        .progress-step.completed .progress-step-icon {
            background: #10b981;
            color: white;
            transform: scale(1.1);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* Enhanced status message styles */
        .status-message {
            padding: 1rem 1.25rem;
            border-radius: 12px;
            margin: 0.75rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }

        .status-message.fade-in {
            opacity: 1;
            transform: translateY(0);
        }

        .status-message.processing {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border: 1px solid #3b82f6;
            color: #1e40af;
        }

        .status-message.success {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border: 1px solid #10b981;
            color: #047857;
        }

        .status-message.error {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            border: 1px solid #ef4444;
            color: #dc2626;
        }

        /* Mobile responsiveness for progress steps */
        @media (max-width: 768px) {
            .progress-steps {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
            
            .progress-step {
                flex-direction: row;
                justify-content: flex-start;
                text-align: left;
            }
            
            .progress-step::after {
                display: none;
            }
        }

        .file-preview {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 16px;
            border: 1px solid #e5e7eb;
        }

        .file-icon {
            width: 50px;
            height: 50px;
            background: #000000;
            color: #ffffff;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .file-info h3 {
            font-weight: 600;
            color: #000000;
            margin-bottom: 5px;
            font-family: "Geist", sans-serif;
        }

        .file-info p {
            color: #6b7280;
            font-size: 0.9rem;
            font-family: "Geist", sans-serif;
        }

        .process-button {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 18px 36px;
            background: linear-gradient(135deg, #000000 0%, #374151 100%);
            color: #ffffff;
            border: none;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            width: 100%;
            justify-content: center;
            margin-bottom: 20px;
            font-family: "Geist", sans-serif;
        }

        .process-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .process-button:hover::before {
            left: 100%;
        }

        .process-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
        }

        .process-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        /* Status Messages */
        .status-message {
            padding: 20px;
            border-radius: 16px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }

        .status-message.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .status-message.processing {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: #ffffff;
        }

        .status-message.success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: #ffffff;
        }

        .status-message.error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #ffffff;
        }

        /* Loading Animation */
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffffff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Dashboard Section - Enhanced with subtle rainbow accent */
        .dashboard-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            border: 1px solid #f1f3f4;
            opacity: 0;
            transform: translateY(40px) scale(0.96);
            transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .dashboard-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dashboard-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .dashboard-card.visible::before {
            opacity: 1;
        }

        .dashboard-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .dashboard-title {
            font-family: "Prata", serif;
            font-size: 2rem;
            font-weight: 400;
            color: #000000;
            margin-bottom: 10px;
        }

        .dashboard-description {
            color: #6b7280;
            font-size: 1.1rem;
            font-family: "Geist", sans-serif;
        }

        .rubric-info {
            background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .rubric-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #000000;
            margin-bottom: 10px;
            font-family: "Geist", sans-serif;
        }

        .rubric-description {
            color: #6b7280;
            margin-bottom: 15px;
            font-family: "Geist", sans-serif;
        }

        .total-points {
            display: inline-flex;
            align-items: center;
            background: #f3f4f6;
            border-radius: 25px;
            padding: 8px 16px;
            font-size: 0.875rem;
            font-weight: 500;
            color: #000000;
            font-family: "Geist", sans-serif;
        }

        .export-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .export-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 16px 24px;
            background: #ffffff;
            color: #000000;
            border: 2px solid #e5e7eb;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            font-family: "Geist", sans-serif;
        }

        .export-button:hover {
            border-color: #000000;
            background: #000000;
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .promptgen-container {
                padding: 0 15px;
            }

            .upload-card,
            .processing-card,
            .dashboard-card {
                padding: 30px 20px;
            }

            .promptgen-title {
                font-size: 2.5rem;
            }

            .export-options {
                grid-template-columns: 1fr;
            }
        }

        /* Animation Classes */
        .fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }

        .slide-up {
            animation: slideUp 0.6s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Success checkmark animation */
        .checkmark {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: block;
            stroke-width: 2;
            stroke: #ffffff;
            stroke-miterlimit: 10;
            box-shadow: inset 0px 0px 0px #ffffff;
            animation: fill .4s ease-in-out .4s forwards, scale .3s ease-in-out .9s both;
        }

        .checkmark__circle {
            stroke-dasharray: 166;
            stroke-dashoffset: 166;
            stroke-width: 2;
            stroke-miterlimit: 10;
            stroke: #ffffff;
            fill: none;
            animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards;
        }

        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards;
        }

        @keyframes stroke {
            100% {
                stroke-dashoffset: 0;
            }
        }

        @keyframes scale {
            0%, 100% {
                transform: none;
            }
            50% {
                transform: scale3d(1.1, 1.1, 1);
            }
        }

        /* Rubric Editor Styles */
        .rubric-editor-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .editor-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-input, .form-textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
            background: white;
            box-sizing: border-box;
        }

        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn-add-criterion {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-add-criterion:hover {
            background: #374151;
            transform: translateY(-1px);
        }

        .criteria-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .criterion-item {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .criterion-item:hover {
            border-color: #d1d5db;
        }

        .criterion-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .criterion-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #000000;
            color: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .btn-remove-criterion {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-remove-criterion:hover {
            background: #dc2626;
        }

        .criterion-examples {
            margin-top: 15px;
        }

        .criterion-examples label {
            font-size: 13px;
            color: #6b7280;
        }

        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .example-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .example-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
        }

        .btn-remove-example {
            background: #f87171;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 11px;
        }

        .btn-add-example {
            margin-top: 8px;
            padding: 6px 12px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            color: #374151;
        }

        .btn-add-example:hover {
            background: #e5e7eb;
        }

        .preview-box {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #374151;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .export-section {
            margin-top: 30px;
            padding: 25px;
            background: #f9fafb;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        .export-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .export-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .export-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .export-button.primary {
            background: #000000;
            color: white;
        }

        .export-button.primary:hover {
            background: #374151;
            transform: translateY(-1px);
            border-color: #374151;
        }

        .export-button.secondary {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .export-button.secondary:hover {
            background: #4f46e5;
            border-color: #4f46e5;
            transform: translateY(-1px);
        }

        .export-button.tertiary {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .export-button.tertiary:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        @keyframes fill {
            100% {
                box-shadow: inset 0px 0px 0px 30px #ffffff;
            }
        }

        /* Dynamic Rubric Structure Styles */
        .section-container {
            margin-bottom: 2rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1rem;
            background-color: #f9f9f9;
        }
        
        .section-header {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0.5rem;
        }
        
        .section-criteria {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .criterion-card {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .criterion-card:hover {
            border-color: #d1d5db;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .criterion-card .criterion-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .criterion-card .criterion-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #000000;
            color: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .criterion-card .criterion-name {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .criterion-card .remove-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .criterion-card .remove-btn:hover {
            background: #dc2626;
        }

        .criterion-body {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .points-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .points-container label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .max-points {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .criterion-description {
            width: 100%;
            min-height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .description-container {
            margin-top: 0.5rem;
        }
        
        .description-container label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            color: #555;
        }

        .examples-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .example-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .example-item input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
        }

        .remove-example {
            background: #f87171;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .remove-example:hover {
            background: #ef4444;
        }

        .add-example-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            color: #374151;
            transition: all 0.3s ease;
        }

        .add-example-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
    </style>

    <!-- Authentication Loading Screen -->
    <style>
        /* Show page content by default - NO HIDING */
        body {
            background: #ffffff;
            visibility: visible;
        }
        
        /* Simple auth overlay - only shows when needed */
        #auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            font-family: 'Geist', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        #auth-overlay.show {
            display: flex;
        }
        
        .auth-content {
            text-align: center;
            padding: 40px;
        }
        
        .auth-logo {
            width: 80px;
            height: auto;
            margin-bottom: 30px;
        }
        
        .auth-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(59, 130, 246, 0.1);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .auth-text {
            color: #64748b;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .auth-subtitle {
            color: #94a3b8;
            font-size: 14px;
            font-weight: 400;
        }
    </style>

    <!-- Simple Authentication Check -->
    <script>
        // Check authentication using our custom session system
        function checkAuth() {
            try {
                // Show auth overlay immediately
                showAuthOverlay();
                
                console.log('Checking authentication...');
                
                // Check for stored session
                const sessionData = localStorage.getItem('oski_session');
                const userData = localStorage.getItem('oski_user');
                
                if (!sessionData || !userData) {
                    console.log('No session found, redirecting to login');
                    hideAuthOverlay();
                    window.location.replace('login.html');
                    return;
                }
                
                const session = JSON.parse(sessionData);
                const user = JSON.parse(userData);
                
                // Check if session is still valid
                if (!session.expires_at || Date.now() >= session.expires_at) {
                    console.log('Session expired, redirecting to login');
                    localStorage.removeItem('oski_session');
                    localStorage.removeItem('oski_user');
                    hideAuthOverlay();
                    window.location.replace('login.html');
                    return;
                }
                
                console.log('User authenticated:', user.email);
                
                // Hide auth overlay with a brief delay for smooth UX
                setTimeout(() => {
                    hideAuthOverlay();
                }, 800);
                
                // Add logout functionality
                window.logout = function() {
                    console.log('Logging out...');
                    localStorage.removeItem('oski_session');
                    localStorage.removeItem('oski_user');
                    window.location.replace('login.html');
                };
                
                // Set up session monitoring
                setInterval(() => {
                    const currentSession = localStorage.getItem('oski_session');
                    if (!currentSession) {
                        console.log('Session removed, redirecting to login');
                        window.location.replace('login.html');
                    } else {
                        const sessionObj = JSON.parse(currentSession);
                        if (Date.now() >= sessionObj.expires_at) {
                            console.log('Session expired during use, redirecting to login');
                            localStorage.removeItem('oski_session');
                            localStorage.removeItem('oski_user');
                            window.location.replace('login.html');
                        }
                    }
                }, 60000); // Check every minute
                
            } catch (error) {
                console.error('Auth check failed:', error);
                localStorage.removeItem('oski_session');
                localStorage.removeItem('oski_user');
                hideAuthOverlay();
                window.location.replace('login.html');
            }
        }
        
        function showAuthOverlay() {
            const overlay = document.getElementById('auth-overlay');
            if (overlay) {
                overlay.classList.add('show');
            }
        }
        
        function hideAuthOverlay() {
            const overlay = document.getElementById('auth-overlay');
            if (overlay) {
                overlay.classList.remove('show');
            }
        }
        
        // Wait for page to load, then check auth
        document.addEventListener('DOMContentLoaded', function() {
            // Add auth overlay to page
            const authHTML = `
                <div id="auth-overlay">
                    <div class="auth-content">
                        <img src="images/Oski.png" alt="Oski" class="auth-logo">
                        <div class="auth-spinner"></div>
                        <div class="auth-text">Verifying access permissions</div>
                        <div class="auth-subtitle">Please wait...</div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', authHTML);
            
            // Check authentication after a brief delay
            setTimeout(checkAuth, 100);
        });
    </script>
</head>

<body>
    <div class="page-wrapper">
        <!-- Header will be injected here -->
        <div id="header-container"></div>

        <!-- Rubricon Section -->
        <section class="promptgen-section">
            <div class="promptgen-container">
                                 <!-- Header -->
                 <div class="promptgen-header fade-in">
                     <div class="top-text">Interactive Demo</div>
                     <h1 class="display-1">Experience Oski's <span class="other-font">Rubricon</span> platform.</h1>
                     <div class="margin-20">
                         <p class="p-02">AI-Powered Rubric to Assessment Prompt Generator</p>
                     </div>
                     <div class="margin-30">
                         <div class="button-flex center-mobile" style="display: flex !important; justify-content: center !important; align-items: center !important; text-align: center !important; width: 100% !important;">
                             <a href="#upload" class="button-first w-inline-block">
                                 <div class="txt-wrapper">
                                     <div class="button-txt">Get Started</div>
                                     <div class="button-txt">Get Started</div>
                                 </div>
                             </a>
                         </div>
                     </div>
                 </div>

                <div class="content-grid">
                    <!-- Upload Section -->
                    <div class="upload-card slide-up" id="upload">
                        <div class="upload-content">
                            <div class="upload-icon">
                                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                            </div>
                            <h2 class="upload-title">Upload Your Rubric</h2>
                            <p class="upload-description">Drag and drop your rubric file here, or click to browse.<br>
                            Supports: PDF, DOC, DOCX, XLS, XLSX, TXT, CSV, and image formats.</p>
                            
                            <input type="file" id="fileInput" class="file-input" accept=".pdf,.doc,.docx,.xls,.xlsx,.txt,.csv,.png,.jpg,.jpeg">
                            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="17 8 12 3 7 8"></polyline>
                                    <line x1="12" y1="3" x2="12" y2="15"></line>
                                </svg>
                                Choose File
                            </button>
                        </div>
                    </div>

                    <!-- Processing Section -->
                    <div class="processing-card" id="processingSection">
                        <div id="filePreview" class="file-preview" style="display: none;">
                            <div class="file-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                    <polyline points="14 2 14 8 20 8"></polyline>
                                </svg>
                            </div>
                            <div class="file-info">
                                <h3 id="fileName">No file selected</h3>
                                <p id="fileSize">Select a file to continue</p>
                            </div>
                        </div>

                        <button class="process-button" id="processButton" disabled onclick="processRubric()">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            Process Rubric
                        </button>

                        <div id="statusMessages"></div>
                    </div>

                    <!-- Dashboard Section -->
                    <div class="dashboard-card" id="dashboardSection">
                        <div class="dashboard-header">
                            <h2 class="dashboard-title">Rubric Editor</h2>
                            <p class="dashboard-description">Review and edit your OSCE assessment criteria before exporting to YAML format.</p>
                        </div>

                        <!-- Rubric Basic Info -->
                        <div class="rubric-editor-section">
                            <div class="editor-header">
                                <h3>Basic Information</h3>
                            </div>

                            <div class="input-group">
                                <label for="systemMessage">System Message:</label>
                                <textarea id="systemMessage" class="form-textarea" rows="3" placeholder="You are a helpful assistant..."></textarea>
                            </div>
                        </div>

                        <!-- Criteria Editor -->
                        <div class="rubric-editor-section">
                            <div class="editor-header">
                                <h3>Assessment Criteria</h3>
                                <button class="btn-add-criterion" onclick="addNewCriterion()">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                    Add Criterion
                                </button>
                            </div>
                            <div id="criteriaContainer" class="criteria-container">
                                <!-- Criteria will be added dynamically -->
                            </div>
                        </div>

                        <!-- User Message Preview -->
                        <div class="rubric-editor-section">
                            <div class="editor-header">
                                <h3>Generated User Message Preview</h3>
                            </div>
                            <div class="preview-box" id="userMessagePreview">
                                <!-- Preview will be generated automatically -->
                            </div>
                        </div>

                        <!-- Export Options -->
                        <div class="export-section">
                            <div class="export-header">
                                <h3>Export Options</h3>
                                <div class="total-points">
                                    Total Points: <span id="totalPoints">0</span>
                                </div>
                            </div>
                            <div class="export-buttons">
                                <button class="export-button primary" onclick="downloadYaml()">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="7 10 12 15 17 10"></polyline>
                                        <line x1="12" y1="15" x2="12" y2="3"></line>
                                    </svg>
                                    Download YAML
                                </button>
                                <button class="export-button tertiary" onclick="resetUpload()">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
                                        <path d="M21 3v5h-5"></path>
                                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
                                        <path d="M3 21v-5h5"></path>
                                    </svg>
                                    Start Over
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Footer will be injected here -->
        <div id="footer-container"></div>
    </div>

    <!-- Oski JavaScript Framework -->
    <script src="js/js-jquery-3.5.1.min.dc5e7f18c8.js" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="js/js-webflow.schunk.36b8fb49256177c8.js" type="text/javascript"></script>
    <script src="js/js-webflow.schunk.4bcee8dc3a55ab3d.js" type="text/javascript"></script>
    <script src="js/js-webflow.965f2b6a.2a699015d3217d92.js" type="text/javascript"></script>
    <script src="js/header.js" type="text/javascript"></script>
    <script src="js/footer.js" type="text/javascript"></script>

    <!-- Rubricon JavaScript -->
    <script>
        let currentFile = null;
        let processedData = null;

        // Perfect adaptive footer state management
        function updateFooterState(state) {
            const body = document.body;
            
            // Remove all existing content state classes
            body.classList.remove('content-state-initial', 'content-state-processing', 'content-state-dashboard');
            
            // Add new state class with smooth transition
            body.classList.add(`content-state-${state}`);
            
            console.log(`Footer state updated to: ${state}`);
        }
        
        // AWS Configuration for Textract + Comprehend Medical
        // SECURITY NOTE: AWS credentials are handled securely by the backend
        // Backend should configure these environment variables:
        // - AWS_ACCESS_KEY_ID=AKIAWGXOJOSG5GSD3KZ3
        // - AWS_SECRET_ACCESS_KEY=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
        // - AWS_REGION=us-east-1
        const AWS_CONFIG = {
            region: 'us-east-1',
            // Credentials handled securely by backend service
            useBackendAuth: true
        };

        // Smart Backend Configuration - FREE VERCEL SERVERLESS FUNCTIONS!
        const getBackendUrl = () => {
            // Check if we're on localhost or deployed
            const hostname = window.location.hostname;
            const isLocal = hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '';
            
            if (isLocal) {
                // Local development - use localhost backend
                return 'http://localhost:8000';
            } else {
                // Production - use Vercel serverless functions (FREE!)
                // The API routes will be at /api/ on the same domain
                return window.location.origin; // Uses same domain as frontend
            }
        };
        
        const BACKEND_URL = getBackendUrl();



        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize footer state
            updateFooterState('initial');
            
            setupFileUpload();
            setupDragAndDrop();
        });

        function setupFileUpload() {
            const fileInput = document.getElementById('fileInput');
            
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    handleFileSelection(file);
                }
            });
        }

        function setupDragAndDrop() {
            const uploadCard = document.getElementById('upload');

            uploadCard.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadCard.classList.add('dragover');
            });

            uploadCard.addEventListener('dragleave', function(e) {
                e.preventDefault();
                uploadCard.classList.remove('dragover');
            });

            uploadCard.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadCard.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileSelection(files[0]);
                }
            });
        }

        function handleFileSelection(file) {
            currentFile = file;
            
            // Update file preview
            const filePreview = document.getElementById('filePreview');
            const fileName = document.getElementById('fileName');
            const fileSize = document.getElementById('fileSize');
            const processButton = document.getElementById('processButton');
            const processingSection = document.getElementById('processingSection');
            const contentGrid = document.querySelector('.content-grid');

            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            
            filePreview.style.display = 'flex';
            processButton.disabled = false;
            
            // Update footer state for file selection
            updateFooterState('processing');
            
            // Show processing section with animation
            processingSection.classList.add('visible');
            
            // Add dynamic spacing
            contentGrid.classList.add('file-uploaded');
            
            // Smooth scroll to processing section
            setTimeout(() => {
                processingSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 300);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /* ============================================ */
        /* ENHANCED RUBRIC PROCESSING SYSTEM         */
        /* ============================================ */
        
        /*
         * COMPREHENSIVE OSCE RUBRIC EXTRACTION
         * 
         * This enhanced system ensures ALL core OSCE sections are extracted:
         * 1. History Taking - Patient communication and interview skills
         * 2. Physical Examination - Clinical examination techniques  
         * 3. Diagnostic Accuracy/Reasoning/Justification - Clinical reasoning
         * 4. Management - Treatment planning and patient education
         * 
         * PROCESSING METHODS (in order of preference):
         * 
         * 1. ENHANCED BACKEND (Best for accuracy):
         *    - Azure Computer Vision API for OCR
         *    - OpenAI GPT-4 for intelligent section extraction
         *    - Pattern matching for validation
         * 
         * 2. ALTERNATIVE APIS (Recommended for better accuracy):
         *    a) Google Cloud Vision API + Document AI
         *       - Free tier: 1,000 requests/month
         *       - Excellent for medical documents
         *       - Setup: https://cloud.google.com/vision
         * 
         *    b) AWS Textract + Comprehend Medical
         *       - $1.50 per 1,000 pages
         *       - Specialized for medical text
         *       - Setup: https://aws.amazon.com/textract/
         * 
         *    c) OpenAI GPT-4 Vision (Most accurate)
         *       - $0.01 per 1K tokens
         *       - Direct document understanding
         *       - Setup: https://platform.openai.com/docs/guides/vision
         * 
         * 3. ENHANCED LOCAL FALLBACK:
         *    - Advanced pattern matching
         *    - Content-based analysis
         *    - Guaranteed all 4 core sections
         * 
         * CURRENT STATUS: Enhanced processing with guaranteed section extraction
         */

        async function processRubric() {
            if (!currentFile) {
                showStatus('error', 'Please select a file first.');
                return;
            }

            const processButton = document.getElementById('processButton');
            const statusMessages = document.getElementById('statusMessages');
            
            // Disable button and show processing state
            processButton.disabled = true;
            processButton.innerHTML = `
                <div class="loading-spinner"></div>
                Processing...
            `;

            // Clear previous status messages
            statusMessages.innerHTML = '';
            
            // Show progress steps
            showProcessingSteps();

            try {
                // Step 1: File Analysis
                updateProgressStep('step-extract', 'active');
                showStatus('processing', 'Analyzing file structure and extracting text...', true);
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const base64Content = await fileToBase64(currentFile);
                updateProgressStep('step-extract', 'completed');
                
                // Step 2: Section Extraction  
                updateProgressStep('step-analyze', 'active');
                showStatus('processing', 'Extracting all OSCE sections with enhanced AI...', true);
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                let rubricData = null;
                
                try {
                    // Try comprehensive backend processing with multiple OCR services first
                    console.log('Attempting comprehensive OCR processing with backend...');
                    rubricData = await processWithComprehensiveOCR(currentFile, base64Content);
                    console.log('Comprehensive OCR processing successful!');
                } catch (backendError) {
                    console.warn('Backend OCR processing failed, trying direct AWS:', backendError.message);
                    
                    try {
                        // Try AWS Textract + Comprehend Medical directly
                        console.log('Attempting direct AWS Textract + Comprehend Medical processing...');
                        rubricData = await processWithAWSTextractComprehend(currentFile, base64Content);
                        console.log('AWS processing successful!');
                    } catch (awsError) {
                        console.warn('AWS processing failed, trying local OCR fallback:', awsError.message);
                    }
                }
                
                // If all OCR methods failed, use dynamic local processing
                if (!rubricData) {
                    showStatus('processing', 'Using dynamic local content analysis...', true);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    rubricData = await generateEnhancedFallbackRubric(currentFile, base64Content);
                }
                
                updateProgressStep('step-analyze', 'completed');
                
                // Step 3: Complete
                updateProgressStep('step-complete', 'active');
                showStatus('processing', 'Finalizing rubric structure...', true);
                await new Promise(resolve => setTimeout(resolve, 500));
                updateProgressStep('step-complete', 'completed');
                
                // Show final success message
                const sectionNames = rubricData.sections ? rubricData.sections.map(s => s.name).join(', ') : 
                                   rubricData.criteria ? rubricData.criteria.map(c => c.name).join(', ') : 'All core sections';
                showStatus('success', `Processed! Found ${rubricData.sections?.length || rubricData.criteria?.length || 4} sections: ${sectionNames}`, true);
                
                // Update process button to show completion
                processButton.classList.add('success');
                processButton.innerHTML = `
                    <svg class="checkmark" width="20" height="20" viewBox="0 0 52 52">
                        <circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none" stroke="#ffffff" stroke-width="2"/>
                        <path class="checkmark__check" fill="none" stroke="#ffffff" stroke-width="2" d="m16 26 6 6 12-12"/>
                    </svg>
                    Processed!
                `;
                
                // Keep the processing card visible but in success state
                const processingSection = document.getElementById('processingSection');
                processingSection.classList.add('processed-success');
                
                // Store processed data globally
                window.currentRubricData = rubricData;
                processedData = rubricData;
                
                // Populate the dashboard with extracted sections
                setTimeout(() => {
                    showDashboard(rubricData);
                }, 1000);
                
            } catch (error) {
                console.error('Processing failed:', error);
                showStatus('error', 'Processing failed. Please try again.');
                
                // Reset button
                processButton.disabled = false;
                processButton.classList.remove('success');
                processButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    Process Rubric
                `;
            }
        }

        // Comprehensive OCR processing with backend (Google Vision + AWS Textract + OCR)
        async function processWithComprehensiveOCR(file, base64Content) {
            console.log('Starting comprehensive OCR processing with backend...');
            
            try {
                // Step 1: Upload file and get comprehensive OCR extraction
                showStatus('processing', 'Backend: Using Google Vision + AWS Textract + OCR...', true);
                
                const uploadResponse = await fetch(`${BACKEND_URL}/api/comprehensive-ocr`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileContent: base64Content,
                        fileName: file.name,
                        fileType: file.type,
                        useMultipleOCR: true,
                        services: ['google_vision', 'aws_textract', 'pytesseract', 'azure_cv'],
                        extractTables: true,
                        extractForms: true
                    })
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`Backend OCR failed: ${uploadResponse.status}`);
                }
                
                const { extracted_text, ocr_results } = await uploadResponse.json();
                console.log('OCR extraction completed:', extracted_text.substring(0, 500) + '...');
                
                // Step 2: Parse rubric structure from extracted text
                showStatus('processing', 'Backend: Parsing rubric structure with AI...', true);
                
                const parseResponse = await fetch(`${BACKEND_URL}/api/parse-rubric`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        extracted_text: extracted_text,
                        file_name: file.name,
                        ocr_results: ocr_results,
                        parse_sections: true,
                        extract_points: true,
                        identify_medical_terms: true
                    })
                });
                
                if (!parseResponse.ok) {
                    throw new Error(`Rubric parsing failed: ${parseResponse.status}`);
                }
                
                const rubricStructure = await parseResponse.json();
                console.log('Parsed rubric structure:', rubricStructure);
                
                return {
                    system_message: rubricStructure.system_message || "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                    user_message_preamble: rubricStructure.user_message_preamble || "Analyze the following medical examination and provide scores for each criterion:",
                    sections: rubricStructure.sections || [],
                    criteria: rubricStructure.criteria || [],
                    rubric_analysis: rubricStructure.rubric_analysis || { sections: [] },
                    assessment_type: rubricStructure.assessment_type || 'Medical Assessment',
                    source_file: file.name,
                    total_points: rubricStructure.total_points || 0,
                    processing_method: 'Comprehensive Backend OCR',
                    ocr_services_used: rubricStructure.ocr_services_used || ['google_vision', 'aws_textract'],
                    extraction_confidence: rubricStructure.extraction_confidence || 0.85
                };
                
            } catch (error) {
                console.error('Comprehensive OCR processing error:', error);
                throw new Error(`Comprehensive OCR processing failed: ${error.message}`);
            }
        }

        // AWS Textract + Comprehend Medical processing via backend
        async function processWithAWSTextractComprehend(file, base64Content) {
            console.log('Starting AWS processing via secure backend...');
            
            try {
                // Use backend for secure AWS processing
                showStatus('processing', 'Backend: AWS Textract + Comprehend Medical analysis...', true);
                
                const response = await fetch(`${BACKEND_URL}/api/aws-processing`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileContent: base64Content,
                        fileName: file.name,
                        fileType: file.type,
                        services: ['textract', 'comprehend_medical'],
                        extractTables: true,
                        extractForms: true,
                        analyzeMedicalEntities: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Backend AWS processing failed: ${response.status}`);
                }
                
                const { extracted_text, medical_entities, textract_data } = await response.json();
                console.log('AWS processing completed via backend');
                
                // Parse rubric structure from AWS results
                showStatus('processing', 'Processing rubric structure with medical intelligence...', true);
                
                const rubricStructure = await parseRubricStructureAdvanced(
                    extracted_text, 
                    { Entities: medical_entities || [] }, 
                    file.name
                );
                
                return rubricStructure;
                
            } catch (error) {
                console.error('Backend AWS processing error:', error);
                throw new Error(`AWS processing failed: ${error.message}`);
            }
        }



        // Advanced rubric structure parsing with medical intelligence - DYNAMIC PARSING
        async function parseRubricStructureAdvanced(extractedText, medicalEntities, fileName) {
            console.log('Parsing rubric structure with medical intelligence...');
            console.log('Extracted text preview:', extractedText.substring(0, 1000));
            
            const lines = extractedText.split('\n').filter(line => line.trim());
            const sections = [];
            
            // DYNAMIC section detection - find actual sections in the uploaded rubric
            const detectedSections = detectSectionsFromText(lines);
            console.log('Detected sections from actual rubric:', detectedSections);
            
            // Parse each detected section dynamically
            for (const detectedSection of detectedSections) {
                const section = {
                    name: detectedSection.name,
                    code: detectedSection.code,
                    maxPoints: detectedSection.totalPoints,
                    items: [],
                    startLine: detectedSection.startLine,
                    endLine: detectedSection.endLine
                };
                
                // Extract actual items from this section
                const sectionLines = lines.slice(detectedSection.startLine, detectedSection.endLine);
                const items = extractActualItemsFromSection(sectionLines, medicalEntities, detectedSection.name);
                section.items = items;
                
                // Calculate total points for section
                section.maxPoints = items.reduce((sum, item) => sum + (item.points || 1), 0);
                
                sections.push(section);
            }
            
            console.log('Dynamically parsed sections:', sections);
            
            // If no sections detected, try fallback parsing
            if (sections.length === 0) {
                console.log('No sections detected, trying fallback parsing...');
                return parseRubricFallback(extractedText, medicalEntities, fileName);
            }
            
            // Return comprehensive rubric structure
            return {
                system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                sections: sections,
                criteria: sections.flatMap(section => 
                    section.items.map(item => ({
                        name: item.description,
                        max_points: item.points,
                        section: section.name,
                        examples: item.examples || [`Assessment of ${item.description.toLowerCase()}`]
                    }))
                ),
                rubric_analysis: {
                    sections: sections.map(section => ({
                        name: section.name,
                        maxPoints: section.maxPoints,
                        items: section.items
                    }))
                },
                assessment_type: 'Dynamic Medical Assessment',
                source_file: fileName,
                total_points: sections.reduce((sum, section) => sum + section.maxPoints, 0),
                processing_method: 'AWS Textract + Comprehend Medical - Dynamic Parsing',
                medicalEntitiesFound: medicalEntities.Entities ? medicalEntities.Entities.length : 0,
                sectionsDetected: sections.length
            };
        }

        // DYNAMIC section detection from actual rubric text
        function detectSectionsFromText(lines) {
            const sections = [];
            let currentSection = null;
            
            // Common section header patterns - these will match any rubric
            const sectionPatterns = [
                /^(history[\s\-_]*taking|patient[\s\-_]*history|history)/i,
                /^(physical[\s\-_]*exam|physical[\s\-_]*examination|examination|exam)/i,
                /^(diagnostic|diagnosis|reasoning|justification|clinical[\s\-_]*reasoning)/i,
                /^(management|treatment|therapeutic|intervention|plan)/i,
                /^(communication|interpersonal|professional)/i,
                /^(documentation|recording|charting)/i,
                /^(safety|infection[\s\-_]*control|sterile)/i,
                /^(assessment|evaluation|scoring)/i
            ];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check if this line is a section header
                const isSection = sectionPatterns.some(pattern => pattern.test(line)) ||
                                line.match(/^[A-Z][a-zA-Z\s\-_]{2,}:?\s*$/); // Generic section headers
                
                if (isSection && line.length > 2 && line.length < 100) {
                    // End previous section
                    if (currentSection) {
                        currentSection.endLine = i;
                        sections.push(currentSection);
                    }
                    
                    // Start new section
                    currentSection = {
                        name: line.replace(/[:;]/g, '').trim(),
                        code: generateSectionCode(line),
                        startLine: i + 1,
                        endLine: lines.length,
                        totalPoints: 0
                    };
                }
            }
            
            // Close last section
            if (currentSection) {
                sections.push(currentSection);
            }
            
            return sections;
        }

        // Generate section code from name
        function generateSectionCode(sectionName) {
            return sectionName.replace(/[^A-Z]/g, '').substring(0, 3) || 
                   sectionName.substring(0, 2).toUpperCase();
        }

        // Extract actual items from a section - DYNAMIC parsing
        function extractActualItemsFromSection(sectionLines, medicalEntities, sectionName) {
            const items = [];
            
            for (const line of sectionLines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.length < 3) continue;
                
                // Skip obvious non-items (headers, empty lines, etc.)
                if (trimmedLine.match(/^(item|criteria|points|total|section)/i)) continue;
                
                // Extract points from line (look for numbers in parentheses or after keywords)
                const pointMatches = trimmedLine.match(/\((\d+)\s*(?:points?|pts?)\)|(\d+)\s*(?:points?|pts?)|(\d+)$/);
                const points = pointMatches ? parseInt(pointMatches[1] || pointMatches[2] || pointMatches[3]) : 1;
                
                // Clean description (remove points notation, bullets, numbers)
                let description = trimmedLine
                    .replace(/\(\d+\s*(?:points?|pts?)\)/g, '')
                    .replace(/^\d+[\.\-\)\s]+/, '')
                    .replace(/^[\-\*\\\\\s]+/, '')
                    .trim();
                
                if (description && description.length > 2) {
                    // Generate contextual examples based on description and medical entities
                    const examples = generateContextualExamples(description, medicalEntities, sectionName);
                    
                    items.push({
                        description: description,
                        points: points,
                        examples: examples,
                        category: generateSectionCode(sectionName)
                    });
                }
            }
            
            return items;
        }

        // Generate contextual examples based on actual rubric content
        function generateContextualExamples(description, medicalEntities, sectionName) {
            const desc = description.toLowerCase();
            const examples = [];
            
            // Use medical entities to enhance examples
            const relevantEntities = medicalEntities.Entities ? 
                medicalEntities.Entities.filter(entity => 
                    desc.includes(entity.Text.toLowerCase()) ||
                    entity.Category === 'MEDICAL_CONDITION' || 
                    entity.Category === 'MEDICATION' ||
                    entity.Category === 'ANATOMY'
                ).slice(0, 2) : [];
            
            // Generate examples based on actual rubric content
            if (desc.includes('chief') || desc.includes('concern') || desc.includes('complaint')) {
                examples.push("What brings you in today?", "Can you tell me about your main concern?");
            } else if (desc.includes('history') && desc.includes('present')) {
                examples.push("Tell me more about this problem", "When did this start?");
            } else if (desc.includes('vital') || desc.includes('signs')) {
                examples.push("I'm going to check your vital signs", "Let me take your blood pressure");
            } else if (desc.includes('exam') || desc.includes('examination')) {
                examples.push(`I'm going to examine ${desc.replace(/examination?|exam/gi, '').trim()}`, 
                            `Physical assessment of ${description.toLowerCase()}`);
            } else if (desc.includes('diagnosis') || desc.includes('diagnostic')) {
                examples.push("Based on my findings, I believe...", `Clinical reasoning for ${description.toLowerCase()}`);
            } else if (desc.includes('treatment') || desc.includes('management') || desc.includes('plan')) {
                examples.push("The treatment plan includes...", `Management approach for ${description.toLowerCase()}`);
            } else {
                // Generic examples based on section and description
                examples.push(`Assessment of ${description.toLowerCase()}`, 
                             `Evaluation related to ${description.toLowerCase()}`);
            }
            
            // Add entity-specific examples
            relevantEntities.forEach(entity => {
                examples.push(`Assessment involving ${entity.Text}`);
            });
            
            return examples.length > 0 ? examples.slice(0, 3) : [`Assessment of ${description}`];
        }

        // Find section content in text
        function findSectionContent(lines, sectionPattern) {
            const sectionLines = [];
            let inSection = false;
            let sectionStart = -1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check if this line matches any section pattern
                const matchesPattern = sectionPattern.patterns.some(pattern => pattern.test(line));
                
                if (matchesPattern && !inSection) {
                    inSection = true;
                    sectionStart = i;
                    sectionLines.push(line);
                } else if (inSection) {
                    // Check if we've hit another section
                    const hitsOtherSection = line.match(/^(History|Physical|Diagnostic|Management)/i) && 
                                           !sectionPattern.patterns.some(pattern => pattern.test(line));
                    
                    if (hitsOtherSection) {
                        break;
                    }
                    
                    sectionLines.push(line);
                    
                    // Stop if we've collected enough lines
                    if (sectionLines.length > 50) break;
                }
            }
            
            return sectionLines;
        }

        // Extract items from section text
        function extractItemsFromSection(sectionLines, medicalEntities, sectionPattern) {
            const items = [];
            
            for (const line of sectionLines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                
                // Skip header lines
                if (trimmedLine.match(/^(History|Physical|Diagnostic|Management)/i)) continue;
                
                // Look for point values in parentheses
                const pointsMatch = trimmedLine.match(/\((\d+)\s*points?\)/i);
                const points = pointsMatch ? parseInt(pointsMatch[1]) : 1;
                
                // Extract description (remove points notation)
                let description = trimmedLine.replace(/\(\d+\s*points?\)/i, '').trim();
                
                // Remove checkbox symbols and numbers
                description = description.replace(/^[\d\s\.\-\*\[\]]+/, '').trim();
                
                if (description && description.length > 3) {
                    // Generate examples based on medical entities and section type
                    const examples = generateExamplesForItem(description, medicalEntities, sectionPattern);
                    
                    items.push({
                        description: description,
                        points: points,
                        examples: examples,
                        category: sectionPattern.code
                    });
                }
            }
            
            // If no items found, add default items for the section
            if (items.length === 0) {
                items.push({
                    description: `${sectionPattern.name} Assessment`,
                    points: Math.floor(sectionPattern.points / 2),
                    examples: [`Assessment of ${sectionPattern.name.toLowerCase()}`],
                    category: sectionPattern.code
                });
            }
            
            return items;
        }

        // Generate examples for rubric items based on medical entities
        function generateExamplesForItem(description, medicalEntities, sectionPattern) {
            const examples = [];
            const desc = description.toLowerCase();
            
            // Use medical entities to enhance examples
            const relevantEntities = medicalEntities.Entities ? 
                medicalEntities.Entities.filter(entity => 
                    entity.Category === 'MEDICAL_CONDITION' || 
                    entity.Category === 'MEDICATION' ||
                    entity.Category === 'ANATOMY'
                ).slice(0, 2) : [];
            
            // Section-specific example generation
            switch (sectionPattern.code) {
                case 'HT': // History Taking
                    if (desc.includes('chief') || desc.includes('concern')) {
                        examples.push("What brings you in today?", "Can you tell me about your main concern?");
                    } else if (desc.includes('rash') || desc.includes('skin')) {
                        examples.push("When did you first notice the rash?", "Has the rash changed over time?");
                    } else if (desc.includes('pain')) {
                        examples.push("On a scale of 1-10, how would you rate your pain?", "What makes the pain better or worse?");
                    } else {
                        examples.push(`Assessment of ${description.toLowerCase()}`, `Questions about ${description.toLowerCase()}`);
                    }
                    break;
                    
                case 'PE': // Physical Examination
                    if (desc.includes('vitals')) {
                        examples.push("I'm going to check your vital signs", "Let me take your blood pressure");
                    } else if (desc.includes('rash') || desc.includes('skin')) {
                        examples.push("I'm going to examine your skin", "Let me look at the affected area");
                    } else {
                        examples.push(`I'm going to examine ${description.toLowerCase()}`, `Physical assessment of ${description.toLowerCase()}`);
                    }
                    break;
                    
                case 'DA': // Diagnostic Accuracy
                    if (desc.includes('diagnosis')) {
                        examples.push("Based on my examination, I believe you have...", "The most likely diagnosis is...");
                    } else {
                        examples.push(`Clinical reasoning for ${description.toLowerCase()}`, `Diagnostic assessment of ${description.toLowerCase()}`);
                    }
                    break;
                    
                case 'M': // Management
                    if (desc.includes('biopsy')) {
                        examples.push("I recommend we do a skin biopsy", "We should take a tissue sample");
                    } else if (desc.includes('medication') || desc.includes('treatment')) {
                        examples.push("I'm going to prescribe...", "The treatment plan includes...");
                    } else {
                        examples.push(`Treatment plan for ${description.toLowerCase()}`, `Management of ${description.toLowerCase()}`);
                    }
                    break;
            }
            
            // Add entity-based examples if relevant
            relevantEntities.forEach(entity => {
                if (desc.includes(entity.Text.toLowerCase())) {
                    examples.push(`Assessment related to ${entity.Text}`);
                }
            });
            
            return examples.length > 0 ? examples : [`Assessment of ${description}`];
        }

                 // DYNAMIC fallback rubric generation - NO TEMPLATES
         async function generateEnhancedFallbackRubric(file, base64Content) {
             console.log('Generating DYNAMIC fallback rubric for:', file.name);
             
             // Try to extract actual text from the file
             let extractedText = '';
             try {
                 if (file.type.includes('text') || file.name.endsWith('.txt')) {
                     extractedText = await file.text();
                 } else {
                     // For binary files, try basic text extraction if possible
                     console.log('Binary file detected, using filename-based analysis');
                     extractedText = file.name;
                 }
             } catch (error) {
                 console.warn('Could not extract text, using filename-based analysis');
                 extractedText = file.name;
             }
             
             console.log('Extracted text for fallback processing:', extractedText.substring(0, 500));
             
             // Parse the actual content dynamically
             const dynamicStructure = parseRubricFallback(extractedText, { Entities: [] }, file.name);
             
             return dynamicStructure;
         }

         // DYNAMIC fallback parsing without templates
         function parseRubricFallback(extractedText, medicalEntities, fileName) {
             console.log('Parsing rubric with dynamic fallback - NO TEMPLATES');
             
             const lines = extractedText.split('\n').filter(line => line.trim());
             
             // If we have actual content, parse it
             if (lines.length > 3 && extractedText.length > 100) {
                 return parseContentBasedRubric(lines, medicalEntities, fileName);
             }
             
             // If no content, create a minimal structure for user to fill in
             return createMinimalRubricStructure(fileName);
         }

         // Parse actual content from the rubric
         function parseContentBasedRubric(lines, medicalEntities, fileName) {
             const sections = [];
             let currentSection = null;
             
             // More comprehensive section detection
             const sectionIndicators = [
                 /history|patient.*history|taking.*history/i,
                 /physical.*exam|examination|clinical.*exam/i,
                 /diagnostic|diagnosis|reasoning|clinical.*reasoning/i,
                 /management|treatment|therapeutic|intervention/i,
                 /communication|interpersonal|professional/i,
                 /documentation|recording|notes/i,
                 /technical.*skills|procedural/i,
                 /assessment|evaluation|overall/i
             ];
             
             for (let i = 0; i < lines.length; i++) {
                 const line = lines[i].trim();
                 
                 // Detect section headers (various formats)
                 const isSection = sectionIndicators.some(pattern => pattern.test(line)) ||
                                 line.match(/^[A-Z][A-Za-z\s\-_]{3,}:?\s*$/) ||
                                 line.match(/^\d+[\.\-\)]\s*[A-Z][A-Za-z\s]{3,}/) ||
                                 (line.length > 5 && line.length < 80 && line === line.toUpperCase());
                 
                 if (isSection) {
                     // Save previous section
                     if (currentSection && currentSection.items.length > 0) {
                         sections.push(currentSection);
                     }
                     
                     // Start new section
                     currentSection = {
                         name: cleanSectionName(line),
                         code: generateSectionCode(line),
                         maxPoints: 0,
                         items: []
                     };
                 } else if (currentSection && line.length > 3) {
                     // Parse potential rubric item
                     const item = parseRubricItem(line);
                     if (item) {
                         currentSection.items.push(item);
                         currentSection.maxPoints += item.points;
                     }
                 }
             }
             
             // Add final section
             if (currentSection && currentSection.items.length > 0) {
                 sections.push(currentSection);
             }
             
             // If no sections found, create structure from content
             if (sections.length === 0) {
                 return createStructureFromContent(lines, fileName);
             }
             
             console.log('Parsed sections from actual content:', sections);
             
             return {
                 system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                 user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                 sections: sections,
                 criteria: sections.flatMap(section => 
                     section.items.map(item => ({
                         name: item.description,
                         max_points: item.points,
                         section: section.name,
                         examples: item.examples
                     }))
                 ),
                 rubric_analysis: { sections: sections },
                 assessment_type: 'Dynamic Medical Assessment from Content',
                 source_file: fileName,
                 total_points: sections.reduce((sum, section) => sum + section.maxPoints, 0),
                 processing_method: 'Dynamic Content Parsing'
             };
         }

         // Parse individual rubric items from lines
         function parseRubricItem(line) {
             const trimmed = line.trim();
             
             // Skip obvious non-items
             if (trimmed.length < 3 || 
                 trimmed.match(/^(total|points|section|criteria|item|score)/i) ||
                 trimmed.match(/^[\-=\*\+\s]+$/)) {
                 return null;
             }
             
             // Extract points
             const pointMatch = trimmed.match(/\((\d+)\s*(?:points?|pts?)\)|(\d+)\s*(?:points?|pts?)|\b(\d+)\s*$/);
             const points = pointMatch ? parseInt(pointMatch[1] || pointMatch[2] || pointMatch[3]) : 1;
             
             // Clean description
             let description = trimmed
                 .replace(/\(\d+\s*(?:points?|pts?)\)/gi, '')
                 .replace(/^\d+[\.\-\)\s]+/, '')
                 .replace(/^[\-\*\\\\\[\]\s]+/, '')
                 .trim();
             
             if (description.length < 2) return null;
             
             // Generate examples based on content
             const examples = generateSmartExamples(description);
             
             return {
                 description: description,
                 points: points,
                 examples: examples
             };
         }

         // Generate smart examples based on item description
         function generateSmartExamples(description) {
             const desc = description.toLowerCase();
             
             if (desc.includes('chief') || desc.includes('concern')) {
                 return ["What brings you in today?", "Tell me about your main concern"];
             } else if (desc.includes('vital') || desc.includes('signs')) {
                 return ["I'll check your vital signs", "Let me take your blood pressure"];
             } else if (desc.includes('exam') || desc.includes('examination')) {
                 return [`I'm going to examine ${desc.replace(/exam.*|examination.*/gi, '').trim()}`, 
                        `Physical assessment of ${description.toLowerCase()}`];
             } else if (desc.includes('diagnosis') || desc.includes('diagnostic')) {
                 return ["Based on my findings...", `Clinical reasoning for ${description.toLowerCase()}`];
             } else {
                 return [`Assessment of ${description.toLowerCase()}`, 
                        `Evaluation related to ${description.toLowerCase()}`];
             }
         }

         // Create structure when no clear sections found
         function createStructureFromContent(lines, fileName) {
             const items = [];
             
             for (const line of lines) {
                 const item = parseRubricItem(line);
                 if (item) items.push(item);
             }
             
             // If items found, create a single general section
             if (items.length > 0) {
                 const totalPoints = items.reduce((sum, item) => sum + item.points, 0);
                 
                 return {
                     system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                     user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                     sections: [{
                         name: "Assessment Criteria",
                         code: "AC",
                         maxPoints: totalPoints,
                         items: items
                     }],
                     criteria: items.map(item => ({
                         name: item.description,
                         max_points: item.points,
                         section: "Assessment Criteria",
                         examples: item.examples
                     })),
                     rubric_analysis: {
                         sections: [{
                             name: "Assessment Criteria",
                             maxPoints: totalPoints,
                             items: items
                         }]
                     },
                     assessment_type: 'Dynamic Assessment from Content',
                     source_file: fileName,
                     total_points: totalPoints,
                     processing_method: 'Content-Based Dynamic Parsing'
                 };
             }
             
             // Last resort - create minimal structure
             return createMinimalRubricStructure(fileName);
         }

         // Clean section names
         function cleanSectionName(name) {
             return name.replace(/^\d+[\.\-\)\s]*/, '')
                       .replace(/[:;]/g, '')
                       .trim();
         }

         // Create minimal structure for user to customize
         function createMinimalRubricStructure(fileName) {
             const basicSection = {
                 name: "Assessment Criteria",
                 code: "AC",
                 maxPoints: 10,
                 items: [
                     {
                         description: "Assessment criterion 1",
                         points: 5,
                         examples: ["Example assessment", "Evaluation criteria"]
                     },
                     {
                         description: "Assessment criterion 2", 
                         points: 5,
                         examples: ["Example assessment", "Evaluation criteria"]
                     }
                 ]
             };
             
             return {
                 system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                 user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                 sections: [basicSection],
                 criteria: basicSection.items.map(item => ({
                     name: item.description,
                     max_points: item.points,
                     section: basicSection.name,
                     examples: item.examples
                 })),
                 rubric_analysis: { sections: [basicSection] },
                 assessment_type: 'Editable Template',
                 source_file: fileName,
                 total_points: 10,
                 processing_method: 'Minimal Template for Customization'
             };
         }
        
        // Enhanced section analysis based on file content
        async function enhanceSectionsFromContent(baseSections, extractedText, fileName) {
            const textLower = extractedText.toLowerCase();
            const enhancedSections = [...baseSections];
            
            // Specialty-specific enhancements based on filename and content
            const specialtyPatterns = {
                'cardiology': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to listen to your heart",
                            "Let me check your pulse",
                            "I'll examine your chest now",
                            "Any chest pain when I press here?"
                        ]
                    }
                },
                'respiratory': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to listen to your lungs",
                            "Take a deep breath for me",
                            "I'll examine your breathing",
                            "Any shortness of breath?"
                        ]
                    }
                },
                'neurology': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to test your reflexes",
                            "Follow my finger with your eyes",
                            "Can you feel this touch?",
                            "Try to resist my movement"
                        ]
                    }
                },
                'abdomen': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to examine your abdomen",
                            "Let me feel for any tenderness",
                            "I'll listen to your bowel sounds",
                            "Any pain when I press here?"
                        ]
                    }
                }
            };
            
            // Check for specialty indicators
            for (const [specialty, enhancements] of Object.entries(specialtyPatterns)) {
                if (textLower.includes(specialty) || fileName.toLowerCase().includes(specialty)) {
                    for (const [sectionName, updates] of Object.entries(enhancements)) {
                        const section = enhancedSections.find(s => s.name === sectionName);
                        if (section && updates.examples) {
                            section.examples = [...section.examples, ...updates.examples];
                        }
                    }
                    break;
                }
            }
            
            return enhancedSections;
        }
        
        // Generate a fallback rubric structure when backend is not available (legacy)
        function generateFallbackRubric(fileName) {
            const baseName = fileName.replace(/\.[^/.]+$/, "");
            
            // Create realistic medical criteria based on filename or default
            const criteria = [
                {
                    name: "History Taking",
                    max_points: 3,
                    examples: [
                        "Can you tell me about your symptoms?",
                        "When did this start?",
                        "On a scale of 1-10, how would you rate your discomfort?"
                    ]
                },
                {
                    name: "Physical Examination",
                    max_points: 2,
                    examples: [
                        "I'm going to examine you now",
                        "Let me check this area", 
                        "I'll be using my stethoscope"
                    ]
                },
                {
                    name: "Diagnostic Accuracy/Reasoning/Justification",
                    max_points: 2,
                    examples: [
                        "Based on what you've told me and my examination findings",
                        "The most likely explanation for your symptoms is",
                        "I want to consider a few different possibilities"
                    ]
                },
                {
                    name: "Management",
                    max_points: 2,
                    examples: [
                        "I recommend we start with this treatment approach",
                        "Here's what I think we should do next",
                        "Let me explain your treatment options"
                    ]
                }
            ];
            
            return {
                system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                criteria: criteria,
                rubric_analysis: {
                    sections: criteria.map((criterion, index) => ({
                        name: criterion.name,
                        maxPoints: criterion.max_points,
                        items: criterion.examples.map((example, exIndex) => ({
                            description: example,
                            points: 1,
                            examples: [`Example for ${example}`, `Assessment of ${example.toLowerCase()}`]
                        }))
                    }))
                }
            };
        }

        let currentRubricData = null;

        function showDashboard(parsedData) {
            console.log('Showing dashboard with data:', parsedData);
            
            // Hide processing, show dashboard
            document.getElementById('processingSection').style.display = 'none';
            const dashboardSection = document.getElementById('dashboardSection');
            
            // Store current data globally for updates
            window.currentRubricData = parsedData;
            
            // Populate basic information
            const systemMessage = parsedData.system_message || 
                'You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.';
            document.getElementById('systemMessage').value = systemMessage;
            
            // Clear and populate assessment criteria
            const criteriaContainer = document.getElementById('criteriaContainer');
            criteriaContainer.innerHTML = '';
            
            // Check if we have rubric_analysis for better section organization
            if (parsedData.rubric_analysis && parsedData.rubric_analysis.sections) {
                console.log('Displaying rubric sections:', parsedData.rubric_analysis.sections);
                displayRubricSections(parsedData.rubric_analysis.sections, criteriaContainer);
            } else if (parsedData.criteria && parsedData.criteria.length > 0) {
                console.log('Displaying criteria:', parsedData.criteria);
                displayCriteria(parsedData.criteria, criteriaContainer);
            } else {
                console.log('No criteria found, adding default criterion');
                // Add a default criterion if none exist
                addNewCriterion();
            }
            
            // Update footer state for dashboard
            updateFooterState('dashboard');
            
            // Add maximum spacing for dashboard
            const contentGrid = document.querySelector('.content-grid');
            contentGrid.classList.add('dashboard-visible');
            
            // Show dashboard section with visibility class
            dashboardSection.style.display = 'block';
            dashboardSection.classList.add('visible');
            
            // Update preview and total points
            setTimeout(() => {
                updateUserMessagePreview();
                updateTotalPoints();
            }, 100);
            
            // Smooth scroll to dashboard
            setTimeout(() => {
                dashboardSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }, 300);
            
            console.log('Dashboard display completed');
        }

        function displayRubricSections(sections, container) {
            sections.forEach((section, sectionIndex) => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'rubric-section';
                sectionDiv.dataset.sectionIndex = sectionIndex;
                
                // Section header with edit capability
                const sectionHeader = document.createElement('div');
                sectionHeader.className = 'section-header-editable';
                sectionHeader.innerHTML = `
                    <div class="section-title-row">
                        <input type="text" 
                               class="section-name-input" 
                               value="${section.name}" 
                               data-section-index="${sectionIndex}"
                               onchange="updateSectionName(${sectionIndex}, this.value)">
                        <div class="section-points">
                            <label>Section Total:</label>
                            <input type="number" 
                                   class="section-max-points" 
                                   value="${section.maxPoints || 0}" 
                                   min="0" 
                                   max="100"
                                   data-section-index="${sectionIndex}"
                                   onchange="updateSectionPoints(${sectionIndex}, this.value)">
                            <span>points</span>
                        </div>
                        <button class="remove-section-btn" onclick="removeSection(${sectionIndex})">Remove Section</button>
                    </div>
                `;
                sectionDiv.appendChild(sectionHeader);
                
                // Items container
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'section-items';
                
                // Display items
                if (section.items && section.items.length > 0) {
                    section.items.forEach((item, itemIndex) => {
                        const itemDiv = createItemElement(item, sectionIndex, itemIndex);
                        itemsContainer.appendChild(itemDiv);
                    });
                }
                
                // Add item button
                const addItemBtn = document.createElement('button');
                addItemBtn.className = 'add-item-btn';
                addItemBtn.textContent = '+ Add Item';
                addItemBtn.onclick = () => addItemToSection(sectionIndex);
                itemsContainer.appendChild(addItemBtn);
                
                sectionDiv.appendChild(itemsContainer);
                container.appendChild(sectionDiv);
            });
            
            // Add new section button
            const addSectionBtn = document.createElement('button');
            addSectionBtn.className = 'add-section-btn';
            addSectionBtn.textContent = '+ Add New Section';
            addSectionBtn.onclick = addNewSection;
            container.appendChild(addSectionBtn);
        }

        function displayCriteria(criteria, container) {
            // Fallback display for criteria without rubric analysis
            if (criteria && criteria.length > 0) {
                criteria.forEach((criterion, index) => {
                    const criterionElement = createCriterionElement(criterion, index);
                    container.appendChild(criterionElement);
                });
            }
        }

        function createItemElement(item, sectionIndex, itemIndex) {
            const div = document.createElement('div');
            div.className = 'rubric-item';
            div.innerHTML = `
                <div class="item-header">
                    <span class="item-number">${itemIndex + 1}.</span>
                    <div class="item-content">
                        <input type="text" 
                               class="item-description" 
                               value="${item.description}" 
                               placeholder="Item description"
                               data-section="${sectionIndex}" 
                               data-item="${itemIndex}"
                               onchange="updateItemDescription(${sectionIndex}, ${itemIndex}, this.value)">
                        <div class="item-points-container">
                            <label>Points:</label>
                            <input type="number" 
                                   class="item-points" 
                                   value="${item.points || 0}" 
                                   min="0" 
                                   max="20"
                                   data-section="${sectionIndex}" 
                                   data-item="${itemIndex}"
                                   onchange="updateItemPoints(${sectionIndex}, ${itemIndex}, this.value)">
                        </div>
                    </div>
                    <button class="remove-item-btn" onclick="removeItem(${sectionIndex}, ${itemIndex})"></button>
                </div>
                <div class="item-examples">
                    <label>Examples/Criteria:</label>
                    <div class="examples-list">
                        ${(item.examples || []).concat(item.criteria || []).map((ex, exIndex) => `
                            <div class="example-item">
                                <input type="text" 
                                       value="${ex}" 
                                       placeholder="Example or criterion"
                                       onchange="updateExample(${sectionIndex}, ${itemIndex}, ${exIndex}, this.value)">
                                <button class="remove-example" onclick="removeExample(${sectionIndex}, ${itemIndex}, ${exIndex})"></button>
                            </div>
                        `).join('')}
                    </div>
                    <button class="add-example-btn" onclick="addExample(${sectionIndex}, ${itemIndex})">+ Add Example</button>
                </div>
            `;
            return div;
        }

        // Add these functions to handle updates
        function updateSectionName(sectionIndex, newName) {
            if (window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections[sectionIndex].name = newName;
            }
            regenerateCriteria();
        }

        function updateSectionPoints(sectionIndex, newPoints) {
            if (window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections[sectionIndex].maxPoints = parseInt(newPoints) || 0;
            }
            updateTotalPoints();
            regenerateCriteria();
        }

        function updateItemDescription(sectionIndex, itemIndex, newDescription) {
            if (window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections[sectionIndex].items[itemIndex].description = newDescription;
            }
            regenerateCriteria();
        }

        function updateItemPoints(sectionIndex, itemIndex, newPoints) {
            if (window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections[sectionIndex].items[itemIndex].points = parseInt(newPoints) || 0;
            }
            updateTotalPoints();
            regenerateCriteria();
        }

        function updateExample(sectionIndex, itemIndex, exampleIndex, newExample) {
            if (window.currentRubricData.rubric_analysis) {
                const item = window.currentRubricData.rubric_analysis.sections[sectionIndex].items[itemIndex];
                const allExamples = (item.examples || []).concat(item.criteria || []);
                allExamples[exampleIndex] = newExample;
                
                // Update the appropriate array
                if (item.examples && exampleIndex < item.examples.length) {
                    item.examples[exampleIndex] = newExample;
                } else {
                    const criteriaIndex = exampleIndex - (item.examples || []).length;
                    if (item.criteria) item.criteria[criteriaIndex] = newExample;
                }
            }
            regenerateCriteria();
        }

        function addExample(sectionIndex, itemIndex) {
            if (window.currentRubricData.rubric_analysis) {
                const item = window.currentRubricData.rubric_analysis.sections[sectionIndex].items[itemIndex];
                if (!item.examples) item.examples = [];
                item.examples.push('New example');
                showDashboard(window.currentRubricData);
            }
        }

        function removeExample(sectionIndex, itemIndex, exampleIndex) {
            if (window.currentRubricData.rubric_analysis) {
                const item = window.currentRubricData.rubric_analysis.sections[sectionIndex].items[itemIndex];
                const allExamples = (item.examples || []).concat(item.criteria || []);
                
                if (exampleIndex < (item.examples || []).length) {
                    item.examples.splice(exampleIndex, 1);
                } else {
                    const criteriaIndex = exampleIndex - (item.examples || []).length;
                    if (item.criteria) item.criteria.splice(criteriaIndex, 1);
                }
                showDashboard(window.currentRubricData);
            }
        }

        function removeItem(sectionIndex, itemIndex) {
            if (window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections[sectionIndex].items.splice(itemIndex, 1);
                showDashboard(window.currentRubricData);
            }
        }

        function removeSection(sectionIndex) {
            if (window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections.splice(sectionIndex, 1);
                showDashboard(window.currentRubricData);
            }
        }

        function addItemToSection(sectionIndex) {
            if (window.currentRubricData.rubric_analysis) {
                const newItem = {
                    description: 'New criterion',
                    points: 1,
                    examples: ['Example 1'],
                    criteria: []
                };
                window.currentRubricData.rubric_analysis.sections[sectionIndex].items.push(newItem);
                showDashboard(window.currentRubricData);
            }
        }

        function addNewSection() {
            if (!window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis = { sections: [] };
            }
            
            const newSection = {
                name: 'New Section',
                maxPoints: 5,
                items: [
                    {
                        description: 'New criterion',
                        points: 1,
                        examples: ['Example 1']
                    }
                ]
            };
            
            window.currentRubricData.rubric_analysis.sections.push(newSection);
            showDashboard(window.currentRubricData);
        }

        function regenerateCriteria() {
            // This would call the backend to regenerate the criteria based on updated sections
            updateUserMessagePreview();
        }

        function createCriterionElement(criterion, index) {
            const div = document.createElement('div');
            div.className = 'criterion-card';
            div.innerHTML = `
                <div class="criterion-header">
                    <span class="criterion-number">${index + 1}</span>
                    <input type="text" 
                           class="criterion-name" 
                           value="${criterion.itemName || criterion.name}" 
                           data-criterion-id="${criterion.id}"
                           onchange="updateUserMessagePreview()">
                    <button class="remove-btn" onclick="removeCriterionNew(this)"></button>
                </div>
                <div class="criterion-body">
                    <div class="points-container">
                        <label>Max Points:</label>
                        <input type="number" 
                               class="max-points" 
                               value="${criterion.max_points}" 
                               min="0" 
                               max="20"
                               onchange="updateUserMessagePreview(); updateTotalPoints();">
                    </div>
                    <div class="description-container">
                        <label>Description:</label>
                        <textarea class="criterion-description" 
                                  rows="2"
                                  onchange="updateUserMessagePreview()">${criterion.description || ''}</textarea>
                    </div>
                    <div class="examples-container">
                        <label>Examples:</label>
                        <div class="examples-list">
                            ${criterion.examples.map(ex => `
                                <div class="example-item">
                                    <input type="text" value="${ex}" onchange="updateUserMessagePreview()">
                                    <button class="remove-example" onclick="removeExampleNew(this)"></button>
                                </div>
                            `).join('')}
                        </div>
                        <button class="add-example-btn" onclick="addExampleNew(this)">+ Add Example</button>
                    </div>
                </div>
            `;
            
            return div;
        }

        function removeCriterionNew(button) {
            const criterionCard = button.closest('.criterion-card');
            criterionCard.remove();
            updateUserMessagePreview();
            updateTotalPoints();
        }

        function addExampleNew(button) {
            const examplesList = button.previousElementSibling;
            const exampleDiv = document.createElement('div');
            exampleDiv.className = 'example-item';
            exampleDiv.innerHTML = `
                <input type="text" value="" onchange="updateUserMessagePreview()">
                <button class="remove-example" onclick="removeExampleNew(this)"></button>
            `;
            examplesList.appendChild(exampleDiv);
        }

        function removeExampleNew(button) {
            const exampleItem = button.closest('.example-item');
            exampleItem.remove();
            updateUserMessagePreview();
        }

        function initializeDashboard(data) {
            console.log('Initializing dashboard with data:', data);
            
            // Set basic information - no key field needed for this format
            document.getElementById('systemMessage').value = data.parsed_yaml?.system_message || 'You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.';
            
            // Load criteria with better error handling
            const criteria = data.parsed_yaml?.criteria || [];
            console.log('Loading criteria:', criteria);
            
            if (criteria.length > 0) {
                loadCriteria(criteria);
                console.log(`Successfully loaded ${criteria.length} criteria`);
            } else {
                console.warn('No criteria found in parsed data');
                loadCriteria([]);
            }
            
            // Update total points
            updateTotalPoints();
            
            // Update preview
            updateUserMessagePreview();
        }

        function loadCriteria(criteria) {
            const container = document.getElementById('criteriaContainer');
            container.innerHTML = '';
            
            console.log('Loading criteria into DOM:', criteria);
            
            if (criteria && criteria.length > 0) {
                criteria.forEach((criterion, index) => {
                    console.log(`Adding criterion ${index + 1}:`, criterion);
                    addCriterionToDOM(criterion, index);
                });
            } else {
                console.log('No criteria provided, adding empty criterion');
                // Add one empty criterion if none exist
                addNewCriterion();
            }
        }

        function addNewCriterion() {
            const criterion = {
                name: '',
                max_points: 1,
                examples: ['']
            };
            const container = document.getElementById('criteriaContainer');
            const index = container.children.length;
            addCriterionToDOM(criterion, index);
            updateTotalPoints();
            updateUserMessagePreview();
        }

        function addCriterionToDOM(criterion, index) {
            const container = document.getElementById('criteriaContainer');
            const criterionDiv = document.createElement('div');
            criterionDiv.className = 'criterion-item';
            criterionDiv.dataset.index = index;
            
            // Ensure criterion has required fields
            const safeGriterion = {
                name: criterion?.name || '',
                max_points: criterion?.max_points || 1,
                examples: criterion?.examples || ['']
            };
            
            // Escape HTML in values to prevent issues
            const escapedName = safeGriterion.name.replace(/"/g, '&quot;');
            const escapedExamples = safeGriterion.examples.map(ex => ex.replace(/"/g, '&quot;'));
            
            criterionDiv.innerHTML = `
                <div class="criterion-header">
                    <div style="display: flex; align-items: center;">
                        <span class="criterion-number">${index + 1}</span>
                        <div style="flex: 1;">
                            <div class="input-group" style="margin-bottom: 10px;">
                                <input type="text" class="form-input criterion-name" placeholder="e.g., Patient Greeting and Introduction" value="${escapedName}" oninput="updateCriterion(${index})">
                            </div>
                            <div class="input-group" style="margin-bottom: 0;">
                                <label>Max Points:</label>
                                <input type="number" class="form-input criterion-points" min="1" max="10" value="${safeGriterion.max_points}" oninput="updateCriterion(${index})" style="width: 80px;">
                            </div>
                        </div>
                    </div>
                    <button class="btn-remove-criterion" onclick="removeCriterion(${index})">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="criterion-examples">
                    <label>Examples:</label>
                    <div class="examples-list">
                        ${escapedExamples.map((example, exampleIndex) => `
                            <div class="example-item">
                                <input type="text" class="example-input" placeholder="e.g., I'm going to examine your..." value="${example}" oninput="updateCriterion(${index})">
                                <button class="btn-remove-example" onclick="removeExample(${index}, ${exampleIndex})"></button>
                            </div>
                        `).join('')}
                    </div>
                    <button class="btn-add-example" onclick="addExample(${index})">+ Add Example</button>
                </div>
            `;
            
            container.appendChild(criterionDiv);
        }

        function updateCriterion(index) {
            updateTotalPoints();
            updateUserMessagePreview();
        }

        function removeCriterion(index) {
            const container = document.getElementById('criteriaContainer');
            const item = container.children[index];
            if (item) {
                item.remove();
                reindexCriteria();
                updateTotalPoints();
                updateUserMessagePreview();
            }
        }

        function addExample(criterionIndex) {
            const container = document.getElementById('criteriaContainer');
            const criterionItem = container.children[criterionIndex];
            const examplesList = criterionItem.querySelector('.examples-list');
            const exampleIndex = examplesList.children.length;
            
            const exampleDiv = document.createElement('div');
            exampleDiv.className = 'example-item';
            exampleDiv.innerHTML = `
                <input type="text" class="example-input" placeholder="e.g., I'm going to examine your..." oninput="updateCriterion(${criterionIndex})">
                <button class="btn-remove-example" onclick="removeExample(${criterionIndex}, ${exampleIndex})"></button>
            `;
            
            examplesList.appendChild(exampleDiv);
        }

        function removeExample(criterionIndex, exampleIndex) {
            const container = document.getElementById('criteriaContainer');
            const criterionItem = container.children[criterionIndex];
            const examplesList = criterionItem.querySelector('.examples-list');
            const exampleItem = examplesList.children[exampleIndex];
            if (exampleItem) {
                exampleItem.remove();
                updateCriterion(criterionIndex);
            }
        }

        function reindexCriteria() {
            const container = document.getElementById('criteriaContainer');
            Array.from(container.children).forEach((item, index) => {
                item.dataset.index = index;
                const numberSpan = item.querySelector('.criterion-number');
                if (numberSpan) numberSpan.textContent = index + 1;
                
                // Update onclick handlers
                item.innerHTML = item.innerHTML
                    .replace(/updateCriterion\(\d+\)/g, `updateCriterion(${index})`)
                    .replace(/removeCriterion\(\d+\)/g, `removeCriterion(${index})`)
                    .replace(/addExample\(\d+\)/g, `addExample(${index})`)
                    .replace(/removeExample\(\d+,\s*\d+\)/g, (match) => {
                        const exampleIndex = match.split(',')[1].replace(/\D/g, '');
                        return `removeExample(${index}, ${exampleIndex})`;
                    });
            });
        }

        function updateTotalPoints() {
            const container = document.getElementById('criteriaContainer');
            let total = 0;
            
            // Handle both old structure (.criterion-points) and new structure (.max-points)
            Array.from(container.children).forEach(item => {
                const pointsInputOld = item.querySelector('.criterion-points');
                const pointsInputsNew = item.querySelectorAll('.max-points');
                const itemPointsInputs = item.querySelectorAll('.item-points');
                
                if (pointsInputOld) {
                    total += parseInt(pointsInputOld.value) || 0;
                }
                
                pointsInputsNew.forEach(input => {
                    total += parseInt(input.value) || 0;
                });
                
                itemPointsInputs.forEach(input => {
                    total += parseInt(input.value) || 0;
                });
            });
            
            // Update both total points displays
            const totalPointsElements = document.querySelectorAll('#totalPoints');
            totalPointsElements.forEach(element => {
                element.textContent = total;
            });
            
            console.log('Total points updated:', total);
        }

        function updateUserMessagePreview() {
            const container = document.getElementById('criteriaContainer');
            const criteria = [];
            
            console.log('Updating user message preview...');
            
            // Handle both old structure and new sectioned structure
            Array.from(container.children).forEach((item, index) => {
                // Skip the add section button
                if (item.classList.contains('add-section-btn')) {
                    return;
                }
                
                // Check if this is a rubric section
                if (item.classList.contains('rubric-section')) {
                    const sectionNameInput = item.querySelector('.section-name-input');
                    const sectionName = sectionNameInput ? sectionNameInput.value.trim() : 'Section';
                    
                    // Get all items in this section
                    const itemElements = item.querySelectorAll('.rubric-item');
                    itemElements.forEach(itemElement => {
                        const itemDescription = itemElement.querySelector('.item-description');
                        const itemPoints = itemElement.querySelector('.item-points');
                        const exampleInputs = itemElement.querySelectorAll('.example-item input');
                        
                        if (itemDescription && itemDescription.value.trim()) {
                            const examples = Array.from(exampleInputs)
                                .map(input => input.value.trim())
                                .filter(value => value);
                            
                            criteria.push({
                                examId: itemDescription.value.trim().replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_'),
                                name: itemDescription.value.trim(),
                                section: sectionName,
                                max_points: parseInt(itemPoints ? itemPoints.value : 1) || 1,
                                examples: examples.length > 0 ? examples : [`Assessment of ${itemDescription.value.trim().toLowerCase()}`]
                            });
                        }
                    });
                } else if (item.classList.contains('criterion-item')) {
                    // Handle old structure
                    const nameInput = item.querySelector('.criterion-name');
                    const pointsInput = item.querySelector('.criterion-points');
                    const exampleInputs = item.querySelectorAll('.example-input');
                    
                    if (nameInput && nameInput.value.trim()) {
                        const examples = Array.from(exampleInputs)
                            .map(input => input.value.trim())
                            .filter(value => value);
                        
                        criteria.push({
                            examId: nameInput.value.trim().replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_'),
                            name: nameInput.value.trim(),
                            max_points: parseInt(pointsInput ? pointsInput.value : 1) || 1,
                            examples: examples.length > 0 ? examples : [`Assessment of ${nameInput.value.trim().toLowerCase()}`]
                        });
                    }
                }
            });
            
            console.log('Extracted criteria for preview:', criteria);
            
            if (criteria.length > 0) {
                const userMessage = generateUserMessage(criteria);
                document.getElementById('userMessagePreview').textContent = userMessage;
            } else {
                document.getElementById('userMessagePreview').textContent = 'No criteria defined yet. Add some assessment criteria to see the preview.';
            }
        }

        function generateUserMessage(criteria) {
            const examsList = criteria.map(c => c.examId || c.name.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_'));
            
            return `
Your task is to identify the start and end times of specific physical exams within the conversation and provide the reasoning behind your choices. Whenever the medical student asks about pain or mentions checking a specific part of the body (e.g., "any pain when I do this?" or "let me check your..."), assume that a physical exam is being conducted at that moment. You will be provided with a description and example for each exam. This station consists of the following physical exams: ${examsList.join(', ')}

Important Instructions:
- When determining the start and end times of each examination, focus on the moments where the doctor instructs the patient to perform an action (e.g., "look up at the ceiling", "look straight ahead"). Give these phrases priority for setting the \`start_time\` and \`end_time\` over phrases where the doctor states their own actions (e.g., "I'm going to look at your nose and eyes").
- Whenever the medical student asks about pain or mentions checking a specific part of the body (e.g., "any pain when I do this?" or "let me check your..."), assume that a physical exam is being conducted at that moment. You will be provided with a description and example for each exam.
- Always pay close attention to surrounding context and related physical examinations mentioned.
   
You need to identify the following physical exams from this transcript: 
${criteria.map((criterion, index) => `	 ${index + 1}. ${criterion.examId || criterion.name.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_')}: Did the doctor ${criterion.name.toLowerCase().includes('did') ? criterion.name.toLowerCase() : `perform ${criterion.name.toLowerCase()}`}? 
	 - Verbalization examples: ${criterion.examples.join(', ')}`).join('\n\n')}


If no exam is detected, you can say "no exam was performed", start_time: "nan", end_time: "nan", score: 0.

### Formatting Instructions

- Ensure strict adherence to JSON formatting.
- Do not use double quotes for multiple statements within a single field.
- Use commas, single quotes, or other appropriate delimiters for multiple statements.
- Do not include any text before or after the JSON output. Provide ONLY the json response.

Please provide a response in the following format with keys: ${examsList.join(', ')}

and the schema: 
{
     "statement": "statement extracted from the transcript that supports this specific exam",
     "start_time": "timepoint for start of the exam (MM:SS only)",
     "end_time": "timepoint for end of the exam (MM:SS only)",
     "rationale": "reasoning behind scoring the physical exam",
     "score": "score of the exam (0 or 1)"
}`;
        }

        async function downloadYaml() {
            console.log('Generating YAML from current dashboard content...');
            
            // Get current dashboard criteria
            const dashboardCriteria = getCurrentDashboardCriteria();
            
            if (dashboardCriteria.length === 0) {
                alert('No criteria available for download. Please add some assessment criteria first.');
                return;
            }
            
            try {
                // Try backend first, then fallback to local generation
                let yamlContent = null;
                
                try {
                    console.log('Attempting to generate YAML via backend...');
                    const response = await fetch(`${BACKEND_URL}/api/generate-prompt`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            dashboard_criteria: dashboardCriteria
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        yamlContent = data.yaml_content;
                        console.log('Backend YAML generation successful');
                    } else {
                        throw new Error('Backend not available');
                    }
                } catch (backendError) {
                    console.warn('Backend YAML generation failed, using local fallback:', backendError.message);
                    
                    // Generate YAML locally
                    yamlContent = generateYamlLocally(dashboardCriteria);
                    console.log('Local YAML generation completed');
                }
                
                if (yamlContent) {
                    downloadFile(yamlContent, 'assessment-rubric.yaml', 'text/yaml');
                    console.log('YAML downloaded successfully');
                    
                    // Show success message
                    showStatus('success', 'YAML file downloaded successfully!');
                } else {
                    throw new Error('Failed to generate YAML content');
                }
                
            } catch (error) {
                console.error('Error generating YAML:', error);
                showStatus('error', 'Failed to generate YAML file. Please try again.');
            }
        }

        function generateYamlLocally(criteria) {
            console.log('Generating YAML locally with criteria:', criteria);
            
            const systemMessage = document.getElementById('systemMessage').value || 
                'You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.';
            
            // Generate the user message
            const userMessage = generateUserMessage(criteria);
            const examsList = criteria.map(c => c.examId || c.name.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_'));
            
            // Create YAML content
            const yamlContent = `system_message: |
  ${systemMessage}

user_message: |
  ${userMessage.split('\n').map(line => '  ' + line).join('\n')}

response_config:
  structured_output: true
  format: json
  schema:
    type: object
    properties:
${examsList.map(examId => `      ${examId}:
        type: object
        properties:
          statement:
            type: string
            description: statement extracted from the transcript that supports this specific exam
          start_time:
            type: string
            description: timepoint for start of the exam (MM:SS only)
          end_time:
            type: string
            description: timepoint for end of the exam (MM:SS only)
          rationale:
            type: string
            description: reasoning behind scoring the physical exam
          score:
            type: integer
            description: score of the exam (0 or 1)
        required: [statement, start_time, end_time, rationale, score]`).join('\n')}
    required: [${examsList.map(id => `"${id}"`).join(', ')}]

# Generated by Oski Rubricon - Medical Assessment Platform
# Date: ${new Date().toISOString()}
# Criteria Count: ${criteria.length}
# Total Points: ${criteria.reduce((sum, c) => sum + (c.max_points || 1), 0)}`;

            return yamlContent;
        }

        function getCurrentDashboardCriteria() {
            const container = document.getElementById('criteriaContainer');
            const criteria = [];
            
            Array.from(container.children).forEach((item, index) => {
                const nameInput = item.querySelector('.criterion-name');
                const pointsInput = item.querySelector('.criterion-points');
                const exampleInputs = item.querySelectorAll('.example-input');
                
                const examples = Array.from(exampleInputs)
                    .map(input => input.value.trim())
                    .filter(value => value);
                
                if (nameInput.value.trim()) {
                    const examId = nameInput.value.trim().replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
                    criteria.push({
                        examId: examId,
                        name: nameInput.value.trim(),
                        max_points: parseInt(pointsInput.value) || 1,
                        examples: examples.length > 0 ? examples : [`I'm going to assess your ${nameInput.value.trim().toLowerCase()}`]
                    });
                }
            });
            
            return criteria;
        }

        function generateCurrentYaml() {
            const systemMessage = document.getElementById('systemMessage').value || 'You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.';
            const userMessage = document.getElementById('userMessagePreview').textContent;
            
            return `system_message: 
   ${systemMessage}
   
user_message: 
  |${userMessage}
response_config:
  structured_output: True`;
        }

        // Missing utility function for converting file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // Remove the data URL prefix to get just the base64 content
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = (error) => reject(error);
            });
        }



        // Enhanced status display function
        function showStatus(type, message, persistent = false) {
            const statusMessages = document.getElementById('statusMessages');
            
            // Create status element
            const statusElement = document.createElement('div');
            statusElement.className = `status-message ${type}`;
            
            // Add appropriate icon based on type
            let icon = '';
            switch(type) {
                case 'processing':
                    icon = '<div class="loading-spinner"></div>';
                    break;
                case 'success':
                    icon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="m9 12 2 2 4-4"/>
                              <circle cx="12" cy="12" r="10"/>
                            </svg>`;
                    break;
                case 'error':
                    icon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <circle cx="12" cy="12" r="10"/>
                              <line x1="15" y1="9" x2="9" y2="15"/>
                              <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>`;
                    break;
            }
            
            statusElement.innerHTML = `${icon}<span>${message}</span>`;
            
            // If not persistent, clear previous non-persistent messages
            if (!persistent) {
                const existingMessages = statusMessages.querySelectorAll('.status-message:not([data-persistent])');
                existingMessages.forEach(msg => msg.remove());
            } else {
                statusElement.setAttribute('data-persistent', 'true');
            }
            
            // Add the new status message
            statusMessages.appendChild(statusElement);
            
            // Add animation class
            statusElement.classList.add('fade-in');
            
            // Auto-remove non-persistent error messages after 5 seconds
            if (type === 'error' && !persistent) {
                setTimeout(() => {
                    if (statusElement.parentNode) {
                        statusElement.remove();
                    }
                }, 5000);
            }
        }

        // Enhanced function to add processing progress steps
        function showProcessingSteps() {
            const statusMessages = document.getElementById('statusMessages');
            
            const progressContainer = document.createElement('div');
            progressContainer.className = 'progress-steps';
            progressContainer.innerHTML = `
                <div class="progress-step completed" id="step-upload">
                    <div class="progress-step-icon"></div>
                    <span>File Upload</span>
                </div>
                <div class="progress-step" id="step-extract">
                    <div class="progress-step-icon">2</div>
                    <span>Text Extraction</span>
                </div>
                <div class="progress-step" id="step-analyze">
                    <div class="progress-step-icon">3</div>
                    <span>OSCE Analysis</span>
                </div>
                <div class="progress-step" id="step-complete">
                    <div class="progress-step-icon">4</div>
                    <span>Complete</span>
                </div>
            `;
            
            statusMessages.appendChild(progressContainer);
        }

        // Function to update progress steps
        function updateProgressStep(stepId, state = 'active') {
            const step = document.getElementById(stepId);
            if (step) {
                step.classList.remove('active', 'completed');
                step.classList.add(state);
                
                if (state === 'completed') {
                    const icon = step.querySelector('.progress-step-icon');
                    icon.innerHTML = '';
                } else if (state === 'active') {
                    const icon = step.querySelector('.progress-step-icon');
                    // Keep the original number for active state
                    if (stepId === 'step-extract') icon.innerHTML = '2';
                    if (stepId === 'step-analyze') icon.innerHTML = '3';
                    if (stepId === 'step-complete') icon.innerHTML = '4';
                }
            }
        }

        // Event listeners for editor updates
        document.addEventListener('DOMContentLoaded', function() {
            // Listen for changes in form inputs to update preview
            document.addEventListener('input', function(e) {
                if (e.target.matches('#systemMessage')) {
                    updateUserMessagePreview();
                }
            });
        });

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            // Show success message
            showStatus('success', `${filename} downloaded successfully!`);
        }

        // Reset functionality
        function resetUpload() {
            currentFile = null;
            processedData = null;
            
            const contentGrid = document.querySelector('.content-grid');
            
            document.getElementById('fileInput').value = '';
            document.getElementById('filePreview').style.display = 'none';
            document.getElementById('processButton').disabled = true;
            document.getElementById('statusMessages').innerHTML = '';
            document.getElementById('processingSection').classList.remove('visible');
            document.getElementById('dashboardSection').classList.remove('visible');
            
            // Reset footer state to initial
            updateFooterState('initial');
            
            // Reset spacing classes
            contentGrid.classList.remove('file-uploaded', 'processing-active', 'dashboard-visible');
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                resetUpload();
            }
        });
    </script>
</body>
</html> 