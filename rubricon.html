<!DOCTYPE html>
<html data-wf-domain="tenet-template.webflow.io" data-wf-page="683d91777124b040c4a5b5cd" data-wf-site="683d91777124b040c4a5b5db" lang="en">
<head>
    <meta charset="utf-8">
    <title>Rubricon | Oski</title>
    <meta content="Transform OSCE rubrics into AI-ready prompts with intelligent OCR processing and automated YAML generation." name="description">
    <meta content="Rubricon - Oski" property="og:title">
    <meta content="Transform OSCE rubrics into AI-ready prompts with intelligent OCR processing and automated YAML generation." property="og:description">
    <meta content="images/OskiPreview.png" property="og:image">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    
    <!-- Supabase Authentication -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- Oski CSS Framework -->
    <link href="https://cdn.prod.website-files.com/683d91777124b040c4a5b5db/css/tenet-template.webflow.shared.40365d26e.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com" rel="preconnect">
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
    <script src="js/1.6.26-webfont.js" type="text/javascript"></script>
    <script type="text/javascript">WebFont.load({  google: {    families: ["Geist:100,200,300,regular,500,600,700,800,900","Prata:regular"]  }});</script>
    <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>

    <!-- Dynamic Favicon -->
    <script>
    function setFavicon() {
      const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const favicon = document.querySelector('link[rel="shortcut icon"]') || document.createElement('link');
      favicon.rel = 'shortcut icon';
      favicon.type = 'image/svg+xml';
      favicon.href = isDarkMode ? 'favicons/White.svg' : 'favicons/Black.svg';
      if (!document.querySelector('link[rel="shortcut icon"]')) {
        document.head.appendChild(favicon);
      }
    }
    setFavicon();
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', setFavicon);
    </script>

    <link href="favicons/683d91777124b040c4a5b5db-683d91777124b040c4a5b63e_logo.png" rel="apple-touch-icon">
    
    <style>
        /* Hide Webflow badge */
        .w-webflow-badge {
            display: none !important;
        }

        /* Rubricon Specific Styles - Beautiful White with Animated Rainbow Gradient */
        .promptgen-section {
            padding: 120px 0 20px;
            background: linear-gradient(135deg, #ffffff 0%, #ffffff 100%);
            min-height: calc(100vh - 200px);
            position: relative;
            overflow: hidden;
        }

        /* Remove the rainbow line */
        .promptgen-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                #ff6b6b 0%, 
                #4ecdc4 14%, 
                #45b7d1 28%, 
                #96ceb4 42%, 
                #ffeaa7 56%, 
                #fab1a0 70%, 
                #fd79a8 84%, 
                #fdcb6e 100%
            );
            background-size: 200% 100%;
            animation: rainbowMove 8s ease-in-out infinite;
            opacity: 0.8;
            z-index: 1;
            display: none;
        }

        /* Subtle animated gradient background for depth */
        .promptgen-section::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(255, 107, 107, 0.02) 0%,
                rgba(78, 205, 196, 0.02) 25%,
                rgba(69, 183, 209, 0.02) 50%,
                rgba(150, 206, 180, 0.02) 75%,
                rgba(255, 234, 167, 0.02) 100%
            );
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            pointer-events: none;
            z-index: 0;
        }

        /* Ensure content appears above the gradient */
        .promptgen-container {
            position: relative;
            z-index: 2;
        }

        @keyframes rainbowMove {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Fix footer and navigation link styling - Remove underlines but keep bold */
        .footer a, .footer .button-first-line {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        .footer a:hover, .footer .button-first-line:hover {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        /* Ensure Navigation and Useful Links sections have no underlines but stay bold */
        .navigation-grid a {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        .navigation-grid a:hover {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        /* Override any conflicting styles */
        .footer .button-line-flex div {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: 600 !important;
        }

        /* Remove underlines from contact links and keep normal weight */
        .footer .title-small a {
            text-decoration: none !important;
            border-bottom: none !important;
            font-weight: normal !important;
        }

        .footer .title-small a:hover {
            text-decoration: none !important;
            border-bottom: none !important;
            opacity: 0.8;
        }

        /* Header navigation link styling */
        .navbar-link {
            text-decoration: none !important;
            border-bottom: none !important;
        }

        .navbar-link:hover {
            text-decoration: none !important;
            border-bottom: none !important;
        }

        /* Header logo normal size */
        .logotype {
            width: 100px !important;
            height: auto !important;
        }

        /* Perfect adaptive footer system */
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .promptgen-section {
            flex: 1;
            padding-bottom: 40px; /* Reduced gap to footer */
            transition: padding-bottom 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ============================================ */
        /* RUBRICON DASHBOARD - OSKI DESIGN LANGUAGE */
        /* ============================================ */
        
        /* Dashboard Container */
        #dashboardSection {
            display: none;
            opacity: 0;
            transform: translateY(40px) scale(0.98);
            transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #dashboardSection.visible {
            display: block;
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        /* Criteria Container with Enhanced Layout */
        #criteriaContainer {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 30px 0;
        }
        
        /* Loading Spinner Styles */
        .processing-spinner-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem 2rem;
            text-align: center;
        }

        .processing-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1.5rem;
        }

        .processing-spinner-container p {
            color: #666;
            margin: 0.5rem 0;
        }

        .processing-note {
            font-size: 0.9rem;
            color: #888;
            font-style: italic;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff40;
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        .processing-success {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            text-align: center;
        }

        .success-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .success-details {
            color: #666;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .processing-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            text-align: center;
        }

        .error-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .error-details {
            color: #dc3545;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Non-editable styles */
        .non-editable {
            color: #6c757d !important;
            background-color: #f8f9fa !important;
            border: 1px solid #e9ecef !important;
            cursor: not-allowed !important;
            user-select: none !important;
            pointer-events: none !important;
        }

        .section-title.non-editable {
            background: none !important;
            border: none !important;
            color: #333 !important;
            font-weight: 600 !important;
            cursor: default !important;
            pointer-events: none !important;
        }

        /* Individual Rubric Sections */
        .rubric-section {
            background: #ffffff;
            border-radius: 20px;
            border: 1px solid #f1f3f4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            padding: 30px;
            margin-bottom: 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slideUpIn 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            opacity: 0;
            transform: translateY(30px);
        }
        
        .rubric-section:nth-child(1) { animation-delay: 0.1s; }
        .rubric-section:nth-child(2) { animation-delay: 0.2s; }
        .rubric-section:nth-child(3) { animation-delay: 0.3s; }
        .rubric-section:nth-child(4) { animation-delay: 0.4s; }
        .rubric-section:nth-child(5) { animation-delay: 0.5s; }
        
        @keyframes slideUpIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .rubric-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #000000, #374151);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .rubric-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12), 0 4px 8px rgba(0, 0, 0, 0.08);
        }
        
        .rubric-section:hover::before {
            opacity: 1;
        }
        
        /* Section Header */
        .section-header-editable {
            margin-bottom: 25px;
        }
        
        .section-title-row {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 0;
            flex-wrap: wrap;
        }
        
        .section-name-input {
            font-size: 1.4rem;
            font-weight: 700;
            color: #1f2937;
            border: 2px solid transparent;
            background: transparent;
            padding: 12px 16px;
            border-radius: 12px;
            flex: 1;
            min-width: 300px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
        }
        
        .section-name-input:focus {
            border-color: #000000;
            background: #f9fafb;
            outline: none;
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .section-name-input:hover {
            background: #f9fafb;
        }
        
        .section-points {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f9fafb;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        .section-points:hover {
            border-color: #d1d5db;
            background: #f3f4f6;
        }
        
        .section-points label {
            font-weight: 600;
            color: #374151;
            margin: 0;
            font-size: 0.9rem;
        }
        
        .section-max-points {
            width: 70px;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 8px 12px;
            text-align: center;
            background: #ffffff;
            font-weight: 600;
            color: #1f2937;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        .section-max-points:focus {
            border-color: #000000;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
        }
        
        /* Items Container */
        .section-items {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* Individual Rubric Items */
        .rubric-item {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .rubric-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #6b7280, #9ca3af);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .rubric-item:hover {
            background: #ffffff;
            border-color: #d1d5db;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .rubric-item:hover::before {
            opacity: 1;
        }
        
        /* Item Header */
        .item-header {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .item-number {
            font-weight: 700;
            color: #374151;
            min-width: 30px;
            background: #ffffff;
            padding: 6px 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e5e7eb;
            font-family: "Geist", sans-serif;
        }
        
        .item-content {
            flex: 1;
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .item-description {
            flex: 1;
            min-width: 250px;
            border: 2px solid transparent;
            border-radius: 12px;
            padding: 14px 16px;
            font-size: 1rem;
            background: #ffffff;
            color: #1f2937;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
            font-weight: 500;
        }
        
        .item-description:focus {
            border-color: #000000;
            outline: none;
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .item-description:hover {
            border-color: #d1d5db;
        }
        
        .item-points-container {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #ffffff;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }
        
        .item-points-container label {
            font-weight: 600;
            color: #374151;
            margin: 0;
            font-size: 0.85rem;
            font-family: "Geist", sans-serif;
        }
        
        .item-points {
            width: 55px;
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 6px 8px;
            text-align: center;
            background: #f9fafb;
            font-weight: 600;
            color: #1f2937;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        .item-points:focus {
            border-color: #000000;
            outline: none;
            background: #ffffff;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
        }
        
        /* Examples Section */
        .item-examples {
            margin-left: 46px;
            margin-top: 16px;
        }
        
        .item-examples label {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
            margin-bottom: 8px;
            display: block;
            font-family: "Geist", sans-serif;
        }
        
        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }
        
        .example-item {
            display: flex;
            gap: 12px;
            align-items: center;
            animation: fadeInUp 0.3s ease forwards;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .example-item input {
            flex: 1;
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 0.9rem;
            background: #ffffff;
            color: #374151;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
        }
        
        .example-item input:focus {
            border-color: #6b7280;
            outline: none;
            box-shadow: 0 0 0 3px rgba(107, 114, 128, 0.1);
            transform: translateY(-1px);
        }
        
        .example-item input:hover {
            border-color: #d1d5db;
            background: #f9fafb;
        }
        
        /* Buttons - Oski Style */
        .remove-section-btn,
        .remove-item-btn,
        .remove-example {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #ffffff;
            border: none;
            border-radius: 10px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            font-family: "Geist", sans-serif;
        }
        
        .remove-section-btn::before,
        .remove-item-btn::before,
        .remove-example::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .remove-section-btn:hover::before,
        .remove-item-btn:hover::before,
        .remove-example:hover::before {
            left: 100%;
        }
        
        .remove-section-btn:hover,
        .remove-item-btn:hover,
        .remove-example:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.3);
        }
        
        .add-item-btn,
        .add-example-btn,
        .add-section-btn {
            background: linear-gradient(135deg, #000000, #374151);
            color: #ffffff;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 12px;
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: "Geist", sans-serif;
        }
        
        .add-item-btn::before,
        .add-example-btn::before,
        .add-section-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .add-item-btn:hover::before,
        .add-example-btn:hover::before,
        .add-section-btn:hover::before {
            left: 100%;
        }
        
        .add-item-btn:hover,
        .add-example-btn:hover,
        .add-section-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .add-section-btn {
            width: 100%;
            font-size: 1.1rem;
            padding: 18px 24px;
            justify-content: center;
            margin-top: 30px;
            border-radius: 16px;
        }
        
        /* Form Elements Consistency */
        #systemMessage,
        #userMessagePreamble,
        #userMessagePreview {
            border: 2px solid transparent;
            border-radius: 16px;
            padding: 20px;
            font-size: 1rem;
            background: #f9fafb;
            color: #1f2937;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: "Geist", sans-serif;
            resize: vertical;
            min-height: 120px;
        }
        
        #systemMessage:focus,
        #userMessagePreamble:focus,
        #userMessagePreview:focus {
            border-color: #000000;
            background: #ffffff;
            outline: none;
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        /* Total Points Display */
        #totalPoints {
            font-size: 1.5rem;
            font-weight: 700;
            color: #000000;
            background: linear-gradient(135deg, #f9fafb, #ffffff);
            padding: 16px 24px;
            border-radius: 16px;
            border: 2px solid #e5e7eb;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .section-title-row {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .section-name-input {
                min-width: unset;
            }
            
            .item-content {
                flex-direction: column;
                align-items: stretch;
            }
            
            .item-description {
                min-width: unset;
            }
            
            .item-examples {
                margin-left: 0;
            }
            
            .rubric-section {
                padding: 20px;
            }
        }

        /* Enhanced section transitions based on state */
        .content-state-processing .promptgen-section {
            padding-bottom: 30px;
        }

        .content-state-dashboard .promptgen-section {
            padding-bottom: 20px;
        }

        /* Clean Dashboard Styles */
        .criterion-item-clean {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .criterion-item-clean:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border-color: #d1d5db;
        }

        .criterion-header-clean {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .criterion-number-clean {
            background: #f3f4f6;
            color: #374151;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }

        .criterion-name-clean {
            flex: 1;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 16px;
            font-weight: 500;
            min-width: 200px;
        }

        .criterion-name-clean:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .criterion-points-clean {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .points-input-clean {
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 10px;
            width: 70px;
            text-align: center;
        }

        .points-input-clean:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .remove-criterion-btn-clean {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .remove-criterion-btn-clean:hover {
            background: #dc2626;
        }

        .examples-section-clean {
            margin-top: 15px;
        }

        .examples-section-clean label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: #374151;
        }

        .examples-list-clean {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .example-item-clean {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .example-input-clean {
            flex: 1;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
        }

        .example-input-clean:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .remove-example-btn-clean {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .remove-example-btn-clean:hover {
            background: #dc2626;
        }

        .add-example-btn-clean {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .add-example-btn-clean:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .footer {
            margin-top: auto;
            background: #ffffff;
            /* Removed border-top line completely */
            transition: margin-top 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Dynamic footer positioning based on content state */
        .content-state-initial .footer {
            margin-top: auto;
        }

        .content-state-processing .footer {
            margin-top: 60px;
        }

        .content-state-dashboard .footer {
            margin-top: 80px;
        }

        /* GLOBAL BUTTON CENTERING - AFFECTS ALL PAGES */
        .button-flex {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            text-align: center !important;
            width: 100% !important;
        }

        .button-flex.center-mobile {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            text-align: center !important;
            width: 100% !important;
        }

        /* Ensure button containers are centered */
        .margin-30 .button-flex,
        .margin-40 .button-flex {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            text-align: center !important;
            width: 100% !important;
        }

        /* Center individual buttons */
        .button-first {
            margin: 0 auto !important;
            display: inline-block !important;
        }

        .promptgen-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .promptgen-header {
            text-align: center;
            margin-bottom: 60px;
            padding-top: 40px;
        }

        .breadcrumb-nav {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 20px;
            text-decoration: none;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }

        .breadcrumb-nav:hover {
            color: #000000;
        }

        .promptgen-title {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 1rem;
            font-family: "Geist", sans-serif;
        }

        .promptgen-subtitle {
            font-size: 1.1rem;
            color: #6b7280;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
            font-family: "Geist", sans-serif;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 40px;
            max-width: 800px;
            margin: 0 auto;
            margin-bottom: 20px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Smooth adaptive content transitions */
        .content-grid.file-uploaded {
            margin-bottom: 30px;
            transform: translateY(0);
        }

        .content-grid.processing-active {
            margin-bottom: 40px;
            transform: translateY(-10px);
        }

        .content-grid.dashboard-visible {
            margin-bottom: 50px;
            transform: translateY(-20px);
        }

        /* Upload Section - Enhanced with subtle rainbow accent */
        .upload-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 2px dashed #e5e7eb;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .upload-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1;
        }

        .upload-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.02), transparent);
            transition: left 0.6s ease;
        }

        .upload-card:hover::before {
            left: 100%;
        }

        .upload-card:hover::after,
        .upload-card.dragover::after {
            opacity: 1;
        }

        .upload-card.dragover {
            border-color: #000000;
            background: #ffffff;
            transform: scale(1.02);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15), 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .upload-content {
            text-align: center;
        }

        .upload-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 30px;
            padding: 20px;
            background: #f3f4f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .upload-card:hover .upload-icon {
            background: #000000;
            color: #ffffff;
            transform: scale(1.1);
        }

        .upload-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #000000;
            margin-bottom: 10px;
            font-family: "Geist", sans-serif;
        }

        .upload-description {
            color: #6b7280;
            margin-bottom: 30px;
            font-size: 1rem;
            font-family: "Geist", sans-serif;
        }

        .file-input {
            display: none;
        }

        .upload-button {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 16px 32px;
            background: #000000;
            color: #ffffff;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            position: relative;
            overflow: hidden;
            font-family: "Geist", sans-serif;
        }

        .upload-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .upload-button:hover::before {
            left: 100%;
        }

        .upload-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        /* Processing Section */
        .processing-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            border: 1px solid #f1f3f4;
            opacity: 0;
            transform: translateY(30px) scale(0.98);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .processing-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            background-size: 200% 100%;
            opacity: 1;
        }

        .processing-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .processing-card.processed-success {
            background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
            border: 2px solid #10b981;
            box-shadow: 0 8px 30px rgba(16, 185, 129, 0.15);
            transform: translateY(0) scale(1);
        }

        .processing-card.processed-success::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
            opacity: 1;
        }

        /* Download Section */
        .download-card {
            background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 8px 30px rgba(16, 185, 129, 0.15), 0 4px 20px rgba(0, 0, 0, 0.06);
            border: 2px solid #10b981;
            opacity: 0;
            transform: translateY(30px) scale(0.98);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            margin-top: 30px;
        }

        .download-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
            opacity: 1;
        }

        .download-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .download-content {
            text-align: center;
        }

        .download-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, #10b981, #059669);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: successPulse 0.8s ease-out;
        }

        .download-icon svg {
            color: white;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        @keyframes successPulse {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .download-title {
            font-size: 1.75rem;
            font-weight: 700;
            color: #047857;
            margin-bottom: 12px;
            font-family: "Geist", sans-serif;
        }

        .download-description {
            font-size: 1rem;
            color: #059669;
            margin-bottom: 32px;
            font-family: "Geist", sans-serif;
        }

        .yaml-preview {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin: 24px 0;
            border: 1px solid rgba(16, 185, 129, 0.2);
            text-align: left;
        }

        .yaml-preview h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #047857;
            margin-bottom: 12px;
            font-family: "Geist", sans-serif;
        }

        .yaml-content {
            background: #f8fafc;
            border-radius: 8px;
            padding: 16px;
            font-family: "Menlo", "Monaco", "Consolas", monospace;
            font-size: 0.875rem;
            color: #374151;
            border: 1px solid #e5e7eb;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .download-actions {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .download-yaml-button {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: "Geist", sans-serif;
        }

        .download-yaml-button:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .process-another-button {
            background: transparent;
            color: #059669;
            border: 2px solid #10b981;
            padding: 14px 32px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: "Geist", sans-serif;
        }

        .process-another-button:hover {
            background: #10b981;
            color: white;
            transform: translateY(-1px);
        }

        /* Process button success state */
        .process-button.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .process-button.success:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
        }

        /* Progress indicator */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin: 2rem 0;
            padding: 0 1rem;
            position: relative;
        }

        .progress-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: #6b7280;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            position: relative;
            flex: 1;
            z-index: 2;
        }

        .progress-step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 16px;
            left: 50%;
            width: 100%;
            height: 2px;
            background: #e5e7eb;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .progress-step.active {
            color: #3b82f6;
            font-weight: 600;
        }

        .progress-step.completed {
            color: #10b981;
            font-weight: 600;
        }

        .progress-step.completed:not(:last-child)::after {
            background: #10b981;
        }

        .progress-step.active:not(:last-child)::after {
            background: linear-gradient(90deg, #3b82f6 50%, #e5e7eb 50%);
        }

        .progress-step-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            z-index: 3;
        }

        .progress-step.active .progress-step-icon {
            background: #3b82f6;
            color: white;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
            animation: pulse 2s infinite;
        }

        .progress-step.completed .progress-step-icon {
            background: #10b981;
            color: white;
            transform: scale(1.1);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* Enhanced status message styles */
        .status-message {
            padding: 1rem 1.25rem;
            border-radius: 12px;
            margin: 0.75rem 0;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }

        .status-message.fade-in {
            opacity: 1;
            transform: translateY(0);
        }

        .status-message.processing {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border: 1px solid #3b82f6;
            color: #1e40af;
        }

        .status-message.success {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border: 1px solid #10b981;
            color: #047857;
        }

        .status-message.error {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            border: 1px solid #ef4444;
            color: #dc2626;
        }

        /* Mobile responsiveness for progress steps */
        @media (max-width: 768px) {
            .progress-steps {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
            
            .progress-step {
                flex-direction: row;
                justify-content: flex-start;
                text-align: left;
            }
            
            .progress-step::after {
                display: none;
            }
        }

        .file-preview {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 16px;
            border: 1px solid #e5e7eb;
        }

        .file-icon {
            width: 50px;
            height: 50px;
            background: #000000;
            color: #ffffff;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .file-info h3 {
            font-weight: 600;
            color: #000000;
            margin-bottom: 5px;
            font-family: "Geist", sans-serif;
        }

        .file-info p {
            color: #6b7280;
            font-size: 0.9rem;
            font-family: "Geist", sans-serif;
        }

        .process-button {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 18px 36px;
            background: linear-gradient(135deg, #000000 0%, #374151 100%);
            color: #ffffff;
            border: none;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            width: 100%;
            justify-content: center;
            margin-bottom: 20px;
            font-family: "Geist", sans-serif;
        }

        .process-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .process-button:hover::before {
            left: 100%;
        }

        .process-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
        }

        .process-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        /* Status Messages */
        .status-message {
            padding: 20px;
            border-radius: 16px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
        }

        .status-message.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .status-message.processing {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: #ffffff;
        }

        .status-message.success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: #ffffff;
        }

        .status-message.error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: #ffffff;
        }

        /* Loading Animation */
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffffff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Dashboard Section - Enhanced with subtle rainbow accent */
        .dashboard-card {
            background: #ffffff;
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            border: 1px solid #f1f3f4;
            opacity: 0;
            transform: translateY(40px) scale(0.96);
            transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .dashboard-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .dashboard-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .dashboard-card.visible::before {
            opacity: 1;
        }

        .dashboard-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .dashboard-title {
            font-family: "Prata", serif;
            font-size: 2rem;
            font-weight: 400;
            color: #000000;
            margin-bottom: 10px;
        }

        .dashboard-description {
            color: #6b7280;
            font-size: 1.1rem;
            font-family: "Geist", sans-serif;
        }

        .rubric-info {
            background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .rubric-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #000000;
            margin-bottom: 10px;
            font-family: "Geist", sans-serif;
        }

        .rubric-description {
            color: #6b7280;
            margin-bottom: 15px;
            font-family: "Geist", sans-serif;
        }

        .total-points {
            display: inline-flex;
            align-items: center;
            background: #f3f4f6;
            border-radius: 25px;
            padding: 8px 16px;
            font-size: 0.875rem;
            font-weight: 500;
            color: #000000;
            font-family: "Geist", sans-serif;
        }

        .export-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .export-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 16px 24px;
            background: #ffffff;
            color: #000000;
            border: 2px solid #e5e7eb;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            font-family: "Geist", sans-serif;
        }

        .export-button:hover {
            border-color: #000000;
            background: #000000;
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .promptgen-container {
                padding: 0 15px;
            }

            .upload-card,
            .processing-card,
            .dashboard-card {
                padding: 30px 20px;
            }

            .promptgen-title {
                font-size: 2.5rem;
            }

            .export-options {
                grid-template-columns: 1fr;
            }
        }

        /* Animation Classes */
        .fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }

        .slide-up {
            animation: slideUp 0.6s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Success checkmark animation */
        .checkmark {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: block;
            stroke-width: 2;
            stroke: #ffffff;
            stroke-miterlimit: 10;
            box-shadow: inset 0px 0px 0px #ffffff;
            animation: fill .4s ease-in-out .4s forwards, scale .3s ease-in-out .9s both;
        }

        .checkmark__circle {
            stroke-dasharray: 166;
            stroke-dashoffset: 166;
            stroke-width: 2;
            stroke-miterlimit: 10;
            stroke: #ffffff;
            fill: none;
            animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards;
        }

        .checkmark__check {
            transform-origin: 50% 50%;
            stroke-dasharray: 48;
            stroke-dashoffset: 48;
            animation: stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards;
        }

        @keyframes stroke {
            100% {
                stroke-dashoffset: 0;
            }
        }

        @keyframes scale {
            0%, 100% {
                transform: none;
            }
            50% {
                transform: scale3d(1.1, 1.1, 1);
            }
        }

        /* Rubric Editor Styles */
        .rubric-editor-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .editor-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-input, .form-textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-family: "Geist", sans-serif;
            background: white;
            box-sizing: border-box;
        }

        .form-input:focus, .form-textarea:focus {
            outline: none;
            border-color: #000000;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn-add-criterion {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-add-criterion:hover {
            background: #374151;
            transform: translateY(-1px);
        }

        .criteria-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .criterion-item {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .criterion-item:hover {
            border-color: #d1d5db;
        }

        .criterion-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .criterion-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #000000;
            color: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .btn-remove-criterion {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-remove-criterion:hover {
            background: #dc2626;
        }

        .criterion-examples {
            margin-top: 15px;
        }

        .criterion-examples label {
            font-size: 13px;
            color: #6b7280;
        }

        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .example-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .example-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
        }

        .btn-remove-example {
            background: #f87171;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 11px;
        }

        .btn-add-example {
            margin-top: 8px;
            padding: 6px 12px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            color: #374151;
        }

        .btn-add-example:hover {
            background: #e5e7eb;
        }

        .preview-box {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #374151;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .export-section {
            margin-top: 30px;
            padding: 25px;
            background: #f9fafb;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        .export-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .export-header h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .export-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .export-button.primary {
            background: #000000;
            color: white;
        }

        .export-button.primary:hover {
            background: #374151;
            transform: translateY(-1px);
            border-color: #374151;
        }

        .export-button.secondary {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .export-button.secondary:hover {
            background: #4f46e5;
            border-color: #4f46e5;
            transform: translateY(-1px);
        }

        .export-button.tertiary {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .export-button.tertiary:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        @keyframes fill {
            100% {
                box-shadow: inset 0px 0px 0px 30px #ffffff;
            }
        }

        /* Dynamic Rubric Structure Styles */
        .section-container {
            margin-bottom: 2rem;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 1rem;
            background-color: #f9f9f9;
        }
        
        .section-header {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0.5rem;
        }
        
        .section-criteria {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .criterion-card {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            transition: all 0.3s ease;
        }

        .criterion-card:hover {
            border-color: #d1d5db;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .criterion-card .criterion-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .criterion-card .criterion-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #000000;
            color: white;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .criterion-card .criterion-name {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .criterion-card .remove-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .criterion-card .remove-btn:hover {
            background: #dc2626;
        }

        .criterion-body {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .points-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .points-container label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .max-points {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .criterion-description {
            width: 100%;
            min-height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .description-container {
            margin-top: 0.5rem;
        }
        
        .description-container label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            color: #555;
        }

        .examples-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .example-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .example-item input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
        }

        .remove-example {
            background: #f87171;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .remove-example:hover {
            background: #ef4444;
        }

        .add-example-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            color: #374151;
            transition: all 0.3s ease;
        }

        .add-example-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
    </style>

    <!-- Authentication Loading Screen -->
    <style>
        /* Show page content by default - NO HIDING */
        body {
            background: #ffffff;
            visibility: visible;
        }
        
        /* Simple auth overlay - only shows when needed */
        #auth-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            font-family: 'Geist', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        #auth-overlay.show {
            display: flex;
        }
        
        .auth-content {
            text-align: center;
            padding: 40px;
        }
        
        .auth-logo {
            width: 80px;
            height: auto;
            margin-bottom: 30px;
        }
        
        .auth-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(59, 130, 246, 0.1);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .auth-text {
            color: #64748b;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .auth-subtitle {
            color: #94a3b8;
            font-size: 14px;
            font-weight: 400;
        }
    </style>

    <!-- Simple Authentication Check -->
    <script>
        // Check authentication using our custom session system
        function checkAuth() {
            try {
                // Show auth overlay immediately
                showAuthOverlay();
                
                console.log('Checking authentication...');
                
                // Check for stored session
                const sessionData = localStorage.getItem('oski_session');
                const userData = localStorage.getItem('oski_user');
                
                if (!sessionData || !userData) {
                    console.log('No session found, redirecting to login');
                    hideAuthOverlay();
                    window.location.replace('login.html');
                    return;
                }
                
                const session = JSON.parse(sessionData);
                const user = JSON.parse(userData);
                
                // Check if session is still valid
                if (!session.expires_at || Date.now() >= session.expires_at) {
                    console.log('Session expired, redirecting to login');
                    localStorage.removeItem('oski_session');
                    localStorage.removeItem('oski_user');
                    hideAuthOverlay();
                    window.location.replace('login.html');
                    return;
                }
                
                console.log('User authenticated:', user.email);
                
                // Hide auth overlay with a brief delay for smooth UX
                setTimeout(() => {
                    hideAuthOverlay();
                }, 800);
                
                // Add logout functionality
                window.logout = function() {
                    console.log('Logging out...');
                    localStorage.removeItem('oski_session');
                    localStorage.removeItem('oski_user');
                    window.location.replace('login.html');
                };
                
                // Set up session monitoring
                setInterval(() => {
                    const currentSession = localStorage.getItem('oski_session');
                    if (!currentSession) {
                        console.log('Session removed, redirecting to login');
                        window.location.replace('login.html');
                    } else {
                        const sessionObj = JSON.parse(currentSession);
                        if (Date.now() >= sessionObj.expires_at) {
                            console.log('Session expired during use, redirecting to login');
                            localStorage.removeItem('oski_session');
                            localStorage.removeItem('oski_user');
                            window.location.replace('login.html');
                        }
                    }
                }, 60000); // Check every minute
                
            } catch (error) {
                console.error('Auth check failed:', error);
                localStorage.removeItem('oski_session');
                localStorage.removeItem('oski_user');
                hideAuthOverlay();
                window.location.replace('login.html');
            }
        }
        
        function showAuthOverlay() {
            const overlay = document.getElementById('auth-overlay');
            if (overlay) {
                overlay.classList.add('show');
            }
        }
        
        function hideAuthOverlay() {
            const overlay = document.getElementById('auth-overlay');
            if (overlay) {
                overlay.classList.remove('show');
            }
        }
        
        // Wait for page to load, then check auth
        document.addEventListener('DOMContentLoaded', function() {
            // Add auth overlay to page
            const authHTML = `
                <div id="auth-overlay">
                    <div class="auth-content">
                        <img src="images/Oski.png" alt="Oski" class="auth-logo">
                        <div class="auth-spinner"></div>
                        <div class="auth-text">Verifying access permissions</div>
                        <div class="auth-subtitle">Please wait...</div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', authHTML);
            
            // Check authentication after a brief delay
            setTimeout(checkAuth, 100);
        });
    </script>
</head>

<body>
    <div class="page-wrapper">
        <!-- Header will be injected here -->
        <div id="header-container"></div>

        <!-- Rubricon Section -->
        <section class="promptgen-section">
            <div class="promptgen-container">
                                 <!-- Header -->
                 <div class="promptgen-header fade-in">
                     <div class="top-text">Interactive Demo</div>
                     <h1 class="display-1">Experience Oski's <span class="other-font">Rubricon</span> platform.</h1>
                     <div class="margin-20">
                         <p class="p-02">AI-Powered Rubric to Assessment Prompt Generator</p>
                     </div>
                     <div class="margin-30">
                         <div class="button-flex center-mobile" style="display: flex !important; justify-content: center !important; align-items: center !important; text-align: center !important; width: 100% !important;">
                             <a href="#upload" class="button-first w-inline-block">
                                 <div class="txt-wrapper">
                                     <div class="button-txt">Get Started</div>
                                     <div class="button-txt">Get Started</div>
                                 </div>
                             </a>
                         </div>
                     </div>
                 </div>

                <div class="content-grid">
                    <!-- Upload Section -->
                    <div class="upload-card slide-up" id="upload">
                        <div class="upload-content">
                            <div class="upload-icon">
                                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                            </div>
                            <h2 class="upload-title">Upload Your Rubric</h2>
                            <p class="upload-description">Drag and drop your rubric file here, or click to browse.<br>
                            Supports: PDF, DOC, DOCX, XLS, and XLSX.</p>
                            
                            <input type="file" id="fileInput" class="file-input" accept=".pdf,.doc,.docx,.xls,.xlsx,.txt,.csv,.png,.jpg,.jpeg">
                            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="17 8 12 3 7 8"></polyline>
                                    <line x1="12" y1="3" x2="12" y2="15"></line>
                                </svg>
                                Choose File
                            </button>
                        </div>
                    </div>

                    <!-- Processing Section -->
                    <div class="processing-card" id="processingSection">
                        <div id="filePreview" class="file-preview" style="display: none;">
                            <div class="file-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                    <polyline points="14 2 14 8 20 8"></polyline>
                                </svg>
                            </div>
                            <div class="file-info">
                                <h3 id="fileName">No file selected</h3>
                                <p id="fileSize">Select a file to continue</p>
                            </div>
                        </div>

                        <button class="process-button" id="processButton" disabled onclick="processRubric()">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            Process Rubric
                        </button>

                        <div id="statusMessages"></div>
                    </div>

                    <!-- Dashboard Section -->
                    <div class="dashboard-card" id="dashboardSection">
                        <div class="dashboard-header">
                            <h2 class="dashboard-title">Rubric Editor</h2>
                            <p class="dashboard-description">Review and edit your OSCE assessment criteria before exporting to YAML format.</p>
                        </div>

                        <!-- Rubric Basic Info -->
                        <div class="rubric-editor-section">
                            <div class="editor-header">
                                <h3>Basic Information</h3>
                            </div>

                            <div class="input-group">
                                <label for="systemMessage">System Message:</label>
                                <textarea id="systemMessage" class="form-textarea" rows="3" placeholder="You are a helpful assistant..."></textarea>
                            </div>
                        </div>

                        <!-- Criteria Editor -->
                        <div class="rubric-editor-section">
                            <div class="editor-header">
                                <h3 class="non-editable">Assessment Criteria</h3>
                                <button class="btn-add-criterion" onclick="addNewCriterion()">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                    Add Criterion
                                </button>
                            </div>
                            <div id="criteriaContainer" class="criteria-container">
                                <!-- Criteria will be added dynamically -->
                            </div>
                        </div>

                        <!-- User Message Preview -->
                        <div class="rubric-editor-section">
                            <div class="editor-header">
                                <h3>Generated User Message Preview</h3>
                            </div>
                            <div class="preview-box" id="userMessagePreview">
                                <!-- Preview will be generated automatically -->
                            </div>
                        </div>

                        <!-- Export Options -->
                        <div class="export-section">
                            <div class="export-header">
                                <h3>Export Options</h3>
                                <div class="total-points">
                                    Total Points: <span id="totalPoints">0</span>
                                </div>
                            </div>
                            <div class="export-buttons">
                                <button class="export-button primary" onclick="downloadYAML()">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="7 10 12 15 17 10"></polyline>
                                        <line x1="12" y1="15" x2="12" y2="3"></line>
                                    </svg>
                                    Download YAML
                                </button>
                                <button class="export-button tertiary" onclick="startOver()">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
                                        <path d="M21 3v5h-5"></path>
                                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
                                        <path d="M3 21v-5h5"></path>
                                    </svg>
                                    Start Over
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Footer will be injected here -->
        <div id="footer-container"></div>
    </div>

    <!-- Oski JavaScript Framework -->
    <script src="js/js-jquery-3.5.1.min.dc5e7f18c8.js" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="js/js-webflow.schunk.36b8fb49256177c8.js" type="text/javascript"></script>
    <script src="js/js-webflow.schunk.4bcee8dc3a55ab3d.js" type="text/javascript"></script>
    <script src="js/js-webflow.965f2b6a.2a699015d3217d92.js" type="text/javascript"></script>
    <script src="js/header.js" type="text/javascript"></script>
    <script src="js/footer.js" type="text/javascript"></script>

    <!-- Rubricon JavaScript -->
    <script>
        let currentFile = null;
        let processedData = null;

        // Perfect adaptive footer state management
        function updateFooterState(state) {
            const body = document.body;
            
            // Remove all existing content state classes
            body.classList.remove('content-state-initial', 'content-state-processing', 'content-state-dashboard');
            
            // Add new state class with smooth transition
            body.classList.add(`content-state-${state}`);
            
            console.log(`Footer state updated to: ${state}`);
        }
        
        // AWS Configuration for Textract + Comprehend Medical
        // SECURITY NOTE: AWS credentials are handled securely by the backend

        const AWS_CONFIG = {
            region: 'us-east-1',
            // Credentials handled securely by backend service
            useBackendAuth: true
        };
        
        // Smart Backend Configuration - FREE VERCEL SERVERLESS FUNCTIONS!
        const getBackendUrl = () => {
            // Check if we're on localhost or deployed
            const hostname = window.location.hostname;
            const isLocal = hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '';
            
            if (isLocal) {
                // Local development - use localhost backend
                return 'http://localhost:8000';
            } else {
                // Production - use Vercel serverless functions (FREE!)
                // The API routes will be at /api/ on the same domain
                return window.location.origin; // Uses same domain as frontend
            }
        };
        
        const BACKEND_URL = getBackendUrl();



        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize footer state
            updateFooterState('initial');
            
            setupFileUpload();
            setupDragAndDrop();
        });

        function setupFileUpload() {
            const fileInput = document.getElementById('fileInput');
            
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    handleFileSelection(file);
                }
            });
        }

        function setupDragAndDrop() {
            const uploadCard = document.getElementById('upload');

            uploadCard.addEventListener('dragover', function(e) {
                e.preventDefault();
                uploadCard.classList.add('dragover');
            });

            uploadCard.addEventListener('dragleave', function(e) {
                e.preventDefault();
                uploadCard.classList.remove('dragover');
            });

            uploadCard.addEventListener('drop', function(e) {
                e.preventDefault();
                uploadCard.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileSelection(files[0]);
                }
            });
        }

        function handleFileSelection(file) {
            currentFile = file;
            
            // Update file preview
            const filePreview = document.getElementById('filePreview');
            const fileName = document.getElementById('fileName');
            const fileSize = document.getElementById('fileSize');
            const processButton = document.getElementById('processButton');
            const processingSection = document.getElementById('processingSection');
            const contentGrid = document.querySelector('.content-grid');

            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            
            filePreview.style.display = 'flex';
            processButton.disabled = false;
            
            // Update footer state for file selection
            updateFooterState('processing');
            
            // Show processing section with animation
            processingSection.classList.add('visible');
            
            // Add dynamic spacing
            contentGrid.classList.add('file-uploaded');
            
            // Smooth scroll to processing section
            setTimeout(() => {
                processingSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 300);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Helper function to convert file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1]; // Remove data:mime;base64, prefix
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function processRubric() {
            if (!currentFile) {
                showStatus('error', 'Please select a file first.');
                return;
            }
            
            const processButton = document.getElementById('processButton');
            const statusMessages = document.getElementById('statusMessages');
            
            // Disable button and show processing state
            processButton.disabled = true;
            processButton.innerHTML = `
                <div class="loading-spinner"></div>
                Processing...
            `;
            
            // Clear previous status messages and show spinner only
            statusMessages.innerHTML = `
                <div class="processing-spinner-container">
                    <div class="processing-spinner"></div>
                    <p>Processing your rubric with advanced AI...</p>
                    <p class="processing-note">Supports: PDF, DOC, DOCX, XLS, XLSX</p>
                </div>
            `;

            try {
                
                let rubricData = null;
                
                try {
                    // Use working backend API
                    console.log('🚀 Processing with backend API...');
                    rubricData = await processWithWorkingAPIs(currentFile);
                    console.log('✅ Backend processing successful!');
                    console.log('🔍 RubricData YAML length:', rubricData?.yaml_content?.length || 0);
                } catch (error) {
                    console.error('❌ Backend processing failed:', error);
                    console.warn('⚠️ Falling back to emergency rubric (no YAML content)');
                    
                    // Create base64 content for fallback processing
                    const base64Content = await fileToBase64(currentFile);
                    rubricData = await generateEnhancedFallbackRubric(currentFile, base64Content);
                }
                
                            // Show final success message
            statusMessages.innerHTML = `
                <div class="processing-success">
                    <div class="success-icon">✅</div>
                    <p>Processing completed! Your rubric is ready for editing.</p>
                    <p class="success-details">You can now customize the assessment criteria below</p>
                </div>
            `;
                
                // Update process button to show completion
                processButton.classList.add('success');
                processButton.innerHTML = `
                    <svg class="checkmark" width="20" height="20" viewBox="0 0 52 52">
                        <circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none" stroke="#ffffff" stroke-width="2"/>
                        <path class="checkmark__check" fill="none" stroke="#ffffff" stroke-width="2" d="m16 26 6 6 12-12"/>
                    </svg>
                    Processed!
                `;
                
                // Keep the processing card visible but in success state
                const processingSection = document.getElementById('processingSection');
                processingSection.classList.add('processed-success');
                
                // Store processed data globally
                window.currentRubricData = rubricData;
                processedData = rubricData;
                
                // Populate the dashboard with extracted sections
                setTimeout(() => {
                    showDashboard(rubricData);
                }, 1000);
                
            } catch (error) {
                console.error('Processing failed:', error);
                
                // Emergency fallback - create a basic rubric structure
                try {
                    console.log('Attempting emergency fallback...');
                    const emergencyRubric = {
                        system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                        sections: [{
                            name: "Assessment Criteria",
                            maxPoints: 20,
                            items: [
                                {
                                    description: "History Taking",
                                    points: 6,
                                    examples: ["Tell me about your symptoms", "When did this start?"]
                                },
                                {
                                    description: "Physical Examination", 
                                    points: 8,
                                    examples: ["I'm going to examine you now", "Let me check this area"]
                                },
                                {
                                    description: "Communication Skills",
                                    points: 4,
                                    examples: ["Do you have any questions?", "Let me explain what I found"]
                                },
                                {
                                    description: "Professional Behavior",
                                    points: 2,
                                    examples: ["I'll wash my hands before examining", "Thank you for your cooperation"]
                                }
                            ]
                        }],
                        criteria: [
                            { name: "History Taking", max_points: 6, examples: ["Tell me about your symptoms", "When did this start?"] },
                            { name: "Physical Examination", max_points: 8, examples: ["I'm going to examine you now", "Let me check this area"] },
                            { name: "Communication Skills", max_points: 4, examples: ["Do you have any questions?", "Let me explain what I found"] },
                            { name: "Professional Behavior", max_points: 2, examples: ["I'll wash my hands before examining", "Thank you for your cooperation"] }
                        ],
                        rubric_analysis: {
                            sections: [{
                                name: "Assessment Criteria",
                                maxPoints: 20,
                                items: [
                                    { description: "History Taking", points: 6, examples: ["Tell me about your symptoms", "When did this start?"] },
                                    { description: "Physical Examination", points: 8, examples: ["I'm going to examine you now", "Let me check this area"] },
                                    { description: "Communication Skills", points: 4, examples: ["Do you have any questions?", "Let me explain what I found"] },
                                    { description: "Professional Behavior", points: 2, examples: ["I'll wash my hands before examining", "Thank you for your cooperation"] }
                                ]
                            }]
                        }
                    };
                    
                    console.log('Emergency fallback successful');
                    
                    // Show success with emergency fallback
                    statusMessages.innerHTML = `
                        <div class="processing-success">
                            <div class="success-icon">✅</div>
                            <p>Processing completed! Your standard assessment criteria are ready.</p>
                            <p class="success-details">You can edit these criteria in the dashboard below</p>
                        </div>
                    `;
                    
                    // Update process button to show completion
                    processButton.classList.add('success');
                    processButton.innerHTML = `
                        <svg class="checkmark" width="20" height="20" viewBox="0 0 52 52">
                            <circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none" stroke="#ffffff" stroke-width="2"/>
                            <path class="checkmark__check" fill="none" stroke="#ffffff" stroke-width="2" d="m16 26 6 6 12-12"/>
                        </svg>
                        Processed!
                    `;
                    
                    // Store the emergency rubric data
                    window.currentRubricData = emergencyRubric;
                    processedData = emergencyRubric;
                    
                    // Show dashboard with emergency data
                    setTimeout(() => {
                        showDashboard(emergencyRubric);
                    }, 1000);
                    
                } catch (emergencyError) {
                    console.error('Emergency fallback also failed:', emergencyError);
                    
                    // Final error display
                    statusMessages.innerHTML = `
                        <div class="processing-error">
                            <div class="error-icon">❌</div>
                            <p>Processing failed. Please try again.</p>
                            <p class="error-details">Error: ${error.message}</p>
                        </div>
                    `;
                
                // Reset button
                processButton.disabled = false;
                processButton.classList.remove('success');
                processButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                    Process Rubric
                `;
                }
            }
        }

        // Get the correct backend URL
        function getBackendURL() {
            // Try different URLs based on the environment
            const possibleURLs = [
                'http://localhost:5003',
                'http://127.0.0.1:5003',
                'http://0.0.0.0:5003'
            ];
            return possibleURLs[0]; // Start with localhost
        }

        // Process using backend.py
        async function processWithWorkingAPIs(file) {
            console.log('🔄 Using backend.py for processing...');
            
            const backendURL = getBackendURL();
            
            try {
                // Upload and process file using your exact backend.py
                console.log('📤 Uploading file to backend...');
                
                const formData = new FormData();
                formData.append('file', file);
                
                console.log('🔄 Making request to', backendURL + '/upload');
                console.log('🔄 File details:', {
                    name: file.name,
                    size: file.size,
                    type: file.type
                });
                
                const uploadResponse = await fetch(backendURL + '/upload', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('📥 Response status:', uploadResponse.status);
                console.log('📥 Response ok:', uploadResponse.ok);
                console.log('📥 Response headers:', [...uploadResponse.headers.entries()]);
                
                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    console.error('❌ Upload failed with response:', errorText);
                    throw new Error(`Upload failed: ${uploadResponse.status} - ${errorText}`);
                }
                
                const uploadResult = await uploadResponse.json();
                console.log('📦 Processing completed:', uploadResult);
                console.log('✅ YAML Content Length:', uploadResult.yaml_content?.length || 0);
                console.log('✅ Filename:', uploadResult.filename);
                console.log('✅ Success:', uploadResult.success);
                console.log('✅ Scoring extracted:', uploadResult.scoring_extracted);
                console.log('✅ Total points:', uploadResult.total_points);
                
                // Debug: Log first 200 characters of YAML content
                if (uploadResult.yaml_content) {
                    console.log('📄 YAML Preview (first 200 chars):', uploadResult.yaml_content.substring(0, 200));
                } else {
                    console.log('❌ No YAML content in response!');
                }
                
                // Store the YAML content for download with validation
                if (uploadResult.yaml_content && uploadResult.yaml_content.length > 0) {
                    window.yamlContent = uploadResult.yaml_content;
                    window.originalFileName = uploadResult.filename;
                    console.log('✅ YAML content stored successfully!');
                    console.log('✅ window.yamlContent length:', window.yamlContent.length);
                    console.log('✅ window.originalFileName:', window.originalFileName);
                } else {
                    console.error('❌ CRITICAL: No YAML content received from backend!');
                    console.error('   uploadResult:', uploadResult);
                    throw new Error('No YAML content received from backend');
                }
                
                // Transform the YAML response into the expected format for display
                const rubricData = {
                    yaml_content: uploadResult.yaml_content,
                    filename: uploadResult.filename,
                    success: true,
                    processing_method: 'backend.py'
                };
                
                console.log('✅ Returning rubricData with yaml_content:', !!rubricData.yaml_content);
                return rubricData;
                
            } catch (error) {
                console.error('Backend processing error:', error);
                throw new Error(`Backend processing failed: ${error.message}`);
            }
        }
        
        // Transform criteria array into sections format
        function transformCriteriaToSections(criteria) {
            if (!criteria || criteria.length === 0) return [];
            
            // Group criteria into a single section or multiple sections based on content
            const section = {
                name: "Assessment Criteria",
                code: "AC",
                maxPoints: criteria.reduce((sum, c) => sum + (c.max_points || 1), 0),
                items: criteria.map(criterion => ({
                    description: criterion.name || criterion.examId || 'Assessment Item',
                    points: criterion.max_points || 1,
                    examples: criterion.examples || [`Assessment of ${criterion.name?.toLowerCase() || 'criterion'}`]
                }))
            };
            
            return [section];
        }

        // Comprehensive OCR processing with backend (Google Vision + AWS Textract + OCR)
        async function processWithComprehensiveOCR(file, base64Content) {
            console.log('Starting comprehensive OCR processing with backend...');
            
            try {
                // Step 1: Upload file and get comprehensive OCR extraction
                showStatus('processing', 'Backend: Using Google Vision + AWS Textract + OCR...', true);
                
                const uploadResponse = await fetch(`${BACKEND_URL}/api/comprehensive-ocr`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fileContent: base64Content,
                        fileName: file.name,
                        fileType: file.type,
                        useMultipleOCR: true,
                        services: ['google_vision', 'aws_textract', 'pytesseract', 'azure_cv'],
                        extractTables: true,
                        extractForms: true
                        })
                    });
                    
                    if (!uploadResponse.ok) {
                    throw new Error(`Backend OCR failed: ${uploadResponse.status}`);
                    }
                    
                const { extracted_text, ocr_results } = await uploadResponse.json();
                console.log('OCR extraction completed:', extracted_text.substring(0, 500) + '...');
                    
                // Step 2: Parse rubric structure from extracted text
                showStatus('processing', 'Backend: Parsing rubric structure with AI...', true);
                    
                const parseResponse = await fetch(`${BACKEND_URL}/api/parse-rubric`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    body: JSON.stringify({
                        extracted_text: extracted_text,
                        file_name: file.name,
                        ocr_results: ocr_results,
                        parse_sections: true,
                        extract_points: true,
                        identify_medical_terms: true
                    })
                });
                
                if (!parseResponse.ok) {
                    throw new Error(`Rubric parsing failed: ${parseResponse.status}`);
                }
                
                const rubricStructure = await parseResponse.json();
                console.log('Parsed rubric structure:', rubricStructure);
                
                return {
                    system_message: rubricStructure.system_message || "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                    user_message_preamble: rubricStructure.user_message_preamble || "Analyze the following medical examination and provide scores for each criterion:",
                    sections: rubricStructure.sections || [],
                    criteria: rubricStructure.criteria || [],
                    rubric_analysis: rubricStructure.rubric_analysis || { sections: [] },
                    assessment_type: rubricStructure.assessment_type || 'Medical Assessment',
                    source_file: file.name,
                    total_points: rubricStructure.total_points || 0,
                    processing_method: 'Comprehensive Backend OCR',
                    ocr_services_used: rubricStructure.ocr_services_used || ['google_vision', 'aws_textract'],
                    extraction_confidence: rubricStructure.extraction_confidence || 0.85
                };
                
            } catch (error) {
                console.error('Comprehensive OCR processing error:', error);
                throw new Error(`Comprehensive OCR processing failed: ${error.message}`);
            }
        }

        // AWS Textract + Comprehend Medical processing via backend
        async function processWithAWSTextractComprehend(file, base64Content) {
            console.log('Starting AWS processing via secure backend...');
            
            try {
                // Use backend for secure AWS processing
                showStatus('processing', 'Backend: AWS Textract + Comprehend Medical analysis...', true);
                
                const response = await fetch(`${BACKEND_URL}/api/aws-processing`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileContent: base64Content,
                        fileName: file.name,
                        fileType: file.type,
                        services: ['textract', 'comprehend_medical'],
                        extractTables: true,
                        extractForms: true,
                        analyzeMedicalEntities: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Backend AWS processing failed: ${response.status}`);
                }
                
                const { extracted_text, medical_entities, textract_data } = await response.json();
                console.log('AWS processing completed via backend');
                
                // Parse rubric structure from AWS results
                showStatus('processing', 'Processing rubric structure with medical intelligence...', true);
                
                const rubricStructure = await parseRubricStructureAdvanced(
                    extracted_text, 
                    { Entities: medical_entities || [] }, 
                    file.name
                );
                
                return rubricStructure;
                
            } catch (error) {
                console.error('Backend AWS processing error:', error);
                throw new Error(`AWS processing failed: ${error.message}`);
            }
        }



        // Advanced rubric structure parsing with medical intelligence - DYNAMIC PARSING
        async function parseRubricStructureAdvanced(extractedText, medicalEntities, fileName) {
            console.log('Parsing rubric structure with medical intelligence...');
            console.log('Extracted text preview:', extractedText.substring(0, 1000));
            
            const lines = extractedText.split('\n').filter(line => line.trim());
            const sections = [];
            
            // DYNAMIC section detection - find actual sections in the uploaded rubric
            const detectedSections = detectSectionsFromText(lines);
            console.log('Detected sections from actual rubric:', detectedSections);
            
            // Parse each detected section dynamically
            for (const detectedSection of detectedSections) {
                const section = {
                    name: detectedSection.name,
                    code: detectedSection.code,
                    maxPoints: detectedSection.totalPoints,
                    items: [],
                    startLine: detectedSection.startLine,
                    endLine: detectedSection.endLine
                };
                
                // Extract actual items from this section
                const sectionLines = lines.slice(detectedSection.startLine, detectedSection.endLine);
                const items = extractActualItemsFromSection(sectionLines, medicalEntities, detectedSection.name);
                section.items = items;
                
                // Calculate total points for section
                section.maxPoints = items.reduce((sum, item) => sum + (item.points || 1), 0);
                
                sections.push(section);
            }
            
            console.log('Dynamically parsed sections:', sections);
            
            // If no sections detected, try fallback parsing
            if (sections.length === 0) {
                console.log('No sections detected, trying fallback parsing...');
                return parseRubricFallback(extractedText, medicalEntities, fileName);
            }
            
            // Return comprehensive rubric structure
            return {
                system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                sections: sections,
                criteria: sections.flatMap(section => 
                    section.items.map(item => ({
                        name: item.description,
                        max_points: item.points,
                        section: section.name,
                        examples: item.examples || [`Assessment of ${item.description.toLowerCase()}`]
                    }))
                ),
                rubric_analysis: {
                    sections: sections.map(section => ({
                        name: section.name,
                        maxPoints: section.maxPoints,
                        items: section.items
                    }))
                },
                assessment_type: 'Dynamic Medical Assessment',
                source_file: fileName,
                total_points: sections.reduce((sum, section) => sum + section.maxPoints, 0),
                processing_method: 'AWS Textract + Comprehend Medical - Dynamic Parsing',
                medicalEntitiesFound: medicalEntities.Entities ? medicalEntities.Entities.length : 0,
                sectionsDetected: sections.length
            };
        }

        // DYNAMIC section detection from actual rubric text
        function detectSectionsFromText(lines) {
            const sections = [];
            let currentSection = null;
            
            // Common section header patterns - these will match any rubric
            const sectionPatterns = [
                /^(history[\s\-_]*taking|patient[\s\-_]*history|history)/i,
                /^(physical[\s\-_]*exam|physical[\s\-_]*examination|examination|exam)/i,
                /^(diagnostic|diagnosis|reasoning|justification|clinical[\s\-_]*reasoning)/i,
                /^(management|treatment|therapeutic|intervention|plan)/i,
                /^(communication|interpersonal|professional)/i,
                /^(documentation|recording|charting)/i,
                /^(safety|infection[\s\-_]*control|sterile)/i,
                /^(assessment|evaluation|scoring)/i
            ];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Check if this line is a section header
                const isSection = sectionPatterns.some(pattern => pattern.test(line)) ||
                                line.match(/^[A-Z][a-zA-Z\s\-_]{2,}:?\s*$/); // Generic section headers
                
                if (isSection && line.length > 2 && line.length < 100) {
                    // End previous section
                    if (currentSection) {
                        currentSection.endLine = i;
                        sections.push(currentSection);
                    }
                    
                    // Start new section
                    currentSection = {
                        name: line.replace(/[:;]/g, '').trim(),
                        code: generateSectionCode(line),
                        startLine: i + 1,
                        endLine: lines.length,
                        totalPoints: 0
                    };
                }
            }
            
            // Close last section
            if (currentSection) {
                sections.push(currentSection);
            }
            
            return sections;
        }

        // Generate section code from name
        function generateSectionCode(sectionName) {
            return sectionName.replace(/[^A-Z]/g, '').substring(0, 3) || 
                   sectionName.substring(0, 2).toUpperCase();
        }

        // Extract actual items from a section - DYNAMIC parsing
        function extractActualItemsFromSection(sectionLines, medicalEntities, sectionName) {
            const items = [];
            
            for (const line of sectionLines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.length < 3) continue;
                
                // Skip obvious non-items (headers, empty lines, etc.)
                if (trimmedLine.match(/^(item|criteria|points|total|section)/i)) continue;
                
                // Extract points from line (look for numbers in parentheses or after keywords)
                const pointMatches = trimmedLine.match(/\((\d+)\s*(?:points?|pts?)\)|(\d+)\s*(?:points?|pts?)|(\d+)$/);
                const points = pointMatches ? parseInt(pointMatches[1] || pointMatches[2] || pointMatches[3]) : 1;
                
                // Clean description (remove points notation, bullets, numbers)
                let description = trimmedLine
                    .replace(/\(\d+\s*(?:points?|pts?)\)/g, '')
                    .replace(/^\d+[\.\-\)\s]+/, '')
                    .replace(/^[\-\*\•\◦\▪\▫\s]+/, '')
                    .trim();
                
                if (description && description.length > 2) {
                    // Generate contextual examples based on description and medical entities
                    const examples = generateContextualExamples(description, medicalEntities, sectionName);
                    
                    items.push({
                        description: description,
                        points: points,
                        examples: examples,
                        category: generateSectionCode(sectionName)
                    });
                }
            }
            
            return items;
        }

        // Generate contextual examples based on actual rubric content
        function generateContextualExamples(description, medicalEntities, sectionName) {
            const desc = description.toLowerCase();
            const examples = [];
            
            // Use medical entities to enhance examples
            const relevantEntities = medicalEntities.Entities ? 
                medicalEntities.Entities.filter(entity => 
                    desc.includes(entity.Text.toLowerCase()) ||
                    entity.Category === 'MEDICAL_CONDITION' || 
                    entity.Category === 'MEDICATION' ||
                    entity.Category === 'ANATOMY'
                ).slice(0, 2) : [];
            
            // Generate examples based on actual rubric content
            if (desc.includes('chief') || desc.includes('concern') || desc.includes('complaint')) {
                examples.push("What brings you in today?", "Can you tell me about your main concern?");
            } else if (desc.includes('history') && desc.includes('present')) {
                examples.push("Tell me more about this problem", "When did this start?");
            } else if (desc.includes('vital') || desc.includes('signs')) {
                examples.push("I'm going to check your vital signs", "Let me take your blood pressure");
            } else if (desc.includes('exam') || desc.includes('examination')) {
                examples.push(`I'm going to examine ${desc.replace(/examination?|exam/gi, '').trim()}`, 
                            `Physical assessment of ${description.toLowerCase()}`);
            } else if (desc.includes('diagnosis') || desc.includes('diagnostic')) {
                examples.push("Based on my findings, I believe...", `Clinical reasoning for ${description.toLowerCase()}`);
            } else if (desc.includes('treatment') || desc.includes('management') || desc.includes('plan')) {
                examples.push("The treatment plan includes...", `Management approach for ${description.toLowerCase()}`);
            } else {
                // Generic examples based on section and description
                examples.push(`Assessment of ${description.toLowerCase()}`, 
                             `Evaluation related to ${description.toLowerCase()}`);
            }
            
            // Add entity-specific examples
            relevantEntities.forEach(entity => {
                examples.push(`Assessment involving ${entity.Text}`);
            });
            
            return examples.length > 0 ? examples.slice(0, 3) : [`Assessment of ${description}`];
        }

        // Find section content in text
        function findSectionContent(lines, sectionPattern) {
            const sectionLines = [];
            let inSection = false;
            let sectionStart = -1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check if this line matches any section pattern
                const matchesPattern = sectionPattern.patterns.some(pattern => pattern.test(line));
                
                if (matchesPattern && !inSection) {
                    inSection = true;
                    sectionStart = i;
                    sectionLines.push(line);
                } else if (inSection) {
                    // Check if we've hit another section
                    const hitsOtherSection = line.match(/^(History|Physical|Diagnostic|Management)/i) && 
                                           !sectionPattern.patterns.some(pattern => pattern.test(line));
                    
                    if (hitsOtherSection) {
                        break;
                    }
                    
                    sectionLines.push(line);
                    
                    // Stop if we've collected enough lines
                    if (sectionLines.length > 50) break;
                }
            }
            
            return sectionLines;
        }

        // Extract items from section text
        function extractItemsFromSection(sectionLines, medicalEntities, sectionPattern) {
            const items = [];
            
            for (const line of sectionLines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                
                // Skip header lines
                if (trimmedLine.match(/^(History|Physical|Diagnostic|Management)/i)) continue;
                
                // Look for point values in parentheses
                const pointsMatch = trimmedLine.match(/\((\d+)\s*points?\)/i);
                const points = pointsMatch ? parseInt(pointsMatch[1]) : 1;
                
                // Extract description (remove points notation)
                let description = trimmedLine.replace(/\(\d+\s*points?\)/i, '').trim();
                
                // Remove checkbox symbols and numbers
                description = description.replace(/^[\d\s\.\-\*\[\]☐☑]+/, '').trim();
                
                if (description && description.length > 3) {
                    // Generate examples based on medical entities and section type
                    const examples = generateExamplesForItem(description, medicalEntities, sectionPattern);
                    
                    items.push({
                        description: description,
                        points: points,
                        examples: examples,
                        category: sectionPattern.code
                    });
                }
            }
            
            // If no items found, add default items for the section
            if (items.length === 0) {
                items.push({
                    description: `${sectionPattern.name} Assessment`,
                    points: Math.floor(sectionPattern.points / 2),
                    examples: [`Assessment of ${sectionPattern.name.toLowerCase()}`],
                    category: sectionPattern.code
                });
            }
            
            return items;
        }

        // Generate examples for rubric items based on medical entities
        function generateExamplesForItem(description, medicalEntities, sectionPattern) {
            const examples = [];
            const desc = description.toLowerCase();
            
            // Use medical entities to enhance examples
            const relevantEntities = medicalEntities.Entities ? 
                medicalEntities.Entities.filter(entity => 
                    entity.Category === 'MEDICAL_CONDITION' || 
                    entity.Category === 'MEDICATION' ||
                    entity.Category === 'ANATOMY'
                ).slice(0, 2) : [];
            
            // Section-specific example generation
            switch (sectionPattern.code) {
                case 'HT': // History Taking
                    if (desc.includes('chief') || desc.includes('concern')) {
                        examples.push("What brings you in today?", "Can you tell me about your main concern?");
                    } else if (desc.includes('rash') || desc.includes('skin')) {
                        examples.push("When did you first notice the rash?", "Has the rash changed over time?");
                    } else if (desc.includes('pain')) {
                        examples.push("On a scale of 1-10, how would you rate your pain?", "What makes the pain better or worse?");
                    } else {
                        examples.push(`Assessment of ${description.toLowerCase()}`, `Questions about ${description.toLowerCase()}`);
                    }
                    break;
                    
                case 'PE': // Physical Examination
                    if (desc.includes('vitals')) {
                        examples.push("I'm going to check your vital signs", "Let me take your blood pressure");
                    } else if (desc.includes('rash') || desc.includes('skin')) {
                        examples.push("I'm going to examine your skin", "Let me look at the affected area");
                    } else {
                        examples.push(`I'm going to examine ${description.toLowerCase()}`, `Physical assessment of ${description.toLowerCase()}`);
                    }
                    break;
                    
                case 'DA': // Diagnostic Accuracy
                    if (desc.includes('diagnosis')) {
                        examples.push("Based on my examination, I believe you have...", "The most likely diagnosis is...");
                    } else {
                        examples.push(`Clinical reasoning for ${description.toLowerCase()}`, `Diagnostic assessment of ${description.toLowerCase()}`);
                    }
                    break;
                    
                case 'M': // Management
                    if (desc.includes('biopsy')) {
                        examples.push("I recommend we do a skin biopsy", "We should take a tissue sample");
                    } else if (desc.includes('medication') || desc.includes('treatment')) {
                        examples.push("I'm going to prescribe...", "The treatment plan includes...");
                    } else {
                        examples.push(`Treatment plan for ${description.toLowerCase()}`, `Management of ${description.toLowerCase()}`);
                    }
                    break;
            }
            
            // Add entity-based examples if relevant
            relevantEntities.forEach(entity => {
                if (desc.includes(entity.Text.toLowerCase())) {
                    examples.push(`Assessment related to ${entity.Text}`);
                }
            });
            
            return examples.length > 0 ? examples : [`Assessment of ${description}`];
        }

                 // DYNAMIC fallback rubric generation - NO TEMPLATES
         async function generateEnhancedFallbackRubric(file, base64Content) {
             console.log('Generating DYNAMIC fallback rubric for:', file.name);
             
             // Try to extract actual text from the file
             let extractedText = '';
             try {
                 if (file.type.includes('text') || file.name.endsWith('.txt')) {
                     extractedText = await file.text();
                 } else {
                     // For binary files, try basic text extraction if possible
                     console.log('Binary file detected, using filename-based analysis');
                     extractedText = file.name;
                 }
             } catch (error) {
                 console.warn('Could not extract text, using filename-based analysis');
                 extractedText = file.name;
             }
             
             console.log('Extracted text for fallback processing:', extractedText.substring(0, 500));
             
             // Parse the actual content dynamically
             const dynamicStructure = parseRubricFallback(extractedText, { Entities: [] }, file.name);
             
             return dynamicStructure;
         }

         // DYNAMIC fallback parsing without templates
         function parseRubricFallback(extractedText, medicalEntities, fileName) {
             console.log('Parsing rubric with dynamic fallback - NO TEMPLATES');
             
             const lines = extractedText.split('\n').filter(line => line.trim());
             
             // If we have actual content, parse it
             if (lines.length > 3 && extractedText.length > 100) {
                 return parseContentBasedRubric(lines, medicalEntities, fileName);
             }
             
             // If no content, create a minimal structure for user to fill in
             return createMinimalRubricStructure(fileName);
         }

         // Parse actual content from the rubric
         function parseContentBasedRubric(lines, medicalEntities, fileName) {
             const sections = [];
             let currentSection = null;
             
             // More comprehensive section detection
             const sectionIndicators = [
                 /history|patient.*history|taking.*history/i,
                 /physical.*exam|examination|clinical.*exam/i,
                 /diagnostic|diagnosis|reasoning|clinical.*reasoning/i,
                 /management|treatment|therapeutic|intervention/i,
                 /communication|interpersonal|professional/i,
                 /documentation|recording|notes/i,
                 /technical.*skills|procedural/i,
                 /assessment|evaluation|overall/i
             ];
             
             for (let i = 0; i < lines.length; i++) {
                 const line = lines[i].trim();
                 
                 // Detect section headers (various formats)
                 const isSection = sectionIndicators.some(pattern => pattern.test(line)) ||
                                 line.match(/^[A-Z][A-Za-z\s\-_]{3,}:?\s*$/) ||
                                 line.match(/^\d+[\.\-\)]\s*[A-Z][A-Za-z\s]{3,}/) ||
                                 (line.length > 5 && line.length < 80 && line === line.toUpperCase());
                 
                 if (isSection) {
                     // Save previous section
                     if (currentSection && currentSection.items.length > 0) {
                         sections.push(currentSection);
                     }
                     
                     // Start new section
                     currentSection = {
                         name: cleanSectionName(line),
                         code: generateSectionCode(line),
                         maxPoints: 0,
                         items: []
                     };
                 } else if (currentSection && line.length > 3) {
                     // Parse potential rubric item
                     const item = parseRubricItem(line);
                     if (item) {
                         currentSection.items.push(item);
                         currentSection.maxPoints += item.points;
                     }
                 }
             }
             
             // Add final section
             if (currentSection && currentSection.items.length > 0) {
                 sections.push(currentSection);
             }
             
             // If no sections found, create structure from content
             if (sections.length === 0) {
                 return createStructureFromContent(lines, fileName);
             }
             
             console.log('Parsed sections from actual content:', sections);
             
             return {
                 system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                 user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                 sections: sections,
                 criteria: sections.flatMap(section => 
                     section.items.map(item => ({
                         name: item.description,
                         max_points: item.points,
                         section: section.name,
                         examples: item.examples
                     }))
                 ),
                 rubric_analysis: { sections: sections },
                 assessment_type: 'Dynamic Medical Assessment from Content',
                 source_file: fileName,
                 total_points: sections.reduce((sum, section) => sum + section.maxPoints, 0),
                 processing_method: 'Dynamic Content Parsing'
             };
         }

         // Parse individual rubric items from lines
         function parseRubricItem(line) {
             const trimmed = line.trim();
             
             // Skip obvious non-items
             if (trimmed.length < 3 || 
                 trimmed.match(/^(total|points|section|criteria|item|score)/i) ||
                 trimmed.match(/^[\-=\*\+\s]+$/)) {
                 return null;
             }
             
             // Extract points
             const pointMatch = trimmed.match(/\((\d+)\s*(?:points?|pts?)\)|(\d+)\s*(?:points?|pts?)|\b(\d+)\s*$/);
             const points = pointMatch ? parseInt(pointMatch[1] || pointMatch[2] || pointMatch[3]) : 1;
             
             // Clean description
             let description = trimmed
                 .replace(/\(\d+\s*(?:points?|pts?)\)/gi, '')
                 .replace(/^\d+[\.\-\)\s]+/, '')
                 .replace(/^[\-\*\•\◦\▪\▫\[\]\s]+/, '')
                 .trim();
             
             if (description.length < 2) return null;
             
             // Generate examples based on content
             const examples = generateSmartExamples(description);
             
             return {
                 description: description,
                 points: points,
                 examples: examples
             };
         }

         // Generate smart examples based on item description
         function generateSmartExamples(description) {
             const desc = description.toLowerCase();
             
             if (desc.includes('chief') || desc.includes('concern')) {
                 return ["What brings you in today?", "Tell me about your main concern"];
             } else if (desc.includes('vital') || desc.includes('signs')) {
                 return ["I'll check your vital signs", "Let me take your blood pressure"];
             } else if (desc.includes('exam') || desc.includes('examination')) {
                 return [`I'm going to examine ${desc.replace(/exam.*|examination.*/gi, '').trim()}`, 
                        `Physical assessment of ${description.toLowerCase()}`];
             } else if (desc.includes('diagnosis') || desc.includes('diagnostic')) {
                 return ["Based on my findings...", `Clinical reasoning for ${description.toLowerCase()}`];
             } else {
                 return [`Assessment of ${description.toLowerCase()}`, 
                        `Evaluation related to ${description.toLowerCase()}`];
             }
         }

         // Create structure when no clear sections found
         function createStructureFromContent(lines, fileName) {
             const items = [];
             
             for (const line of lines) {
                 const item = parseRubricItem(line);
                 if (item) items.push(item);
             }
             
             // If items found, create a single general section
             if (items.length > 0) {
                 const totalPoints = items.reduce((sum, item) => sum + item.points, 0);
                 
                 return {
                     system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                     user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                     sections: [{
                         name: "Assessment Criteria",
                         code: "AC",
                         maxPoints: totalPoints,
                         items: items
                     }],
                     criteria: items.map(item => ({
                         name: item.description,
                         max_points: item.points,
                         section: "Assessment Criteria",
                         examples: item.examples
                     })),
                     rubric_analysis: {
                         sections: [{
                             name: "Assessment Criteria",
                             maxPoints: totalPoints,
                             items: items
                         }]
                     },
                     assessment_type: 'Dynamic Assessment from Content',
                     source_file: fileName,
                     total_points: totalPoints,
                     processing_method: 'Content-Based Dynamic Parsing'
                 };
             }
             
             // Last resort - create minimal structure
             return createMinimalRubricStructure(fileName);
         }

         // Clean section names
         function cleanSectionName(name) {
             return name.replace(/^\d+[\.\-\)\s]*/, '')
                       .replace(/[:;]/g, '')
                       .trim();
         }

         // Generate smarter criteria based on filename and medical patterns
         function generateFileBasedCriteria(fileName) {
             const fileNameLower = fileName.toLowerCase();
             
             // Detect medical specialty or assessment type from filename
             if (fileNameLower.includes('cardio') || fileNameLower.includes('heart')) {
                 return [
                     {
                         description: "Cardiovascular History Taking",
                         points: 3,
                         examples: ["Tell me about your chest pain", "Any history of heart problems?", "Are you taking any heart medications?"]
                     },
                     {
                         description: "Cardiac Physical Examination",
                         points: 4,
                         examples: ["I'm going to listen to your heart", "Let me check your pulse", "I'll examine your chest now"]
                     },
                     {
                         description: "Clinical Reasoning - Cardiac",
                         points: 3,
                         examples: ["Based on your symptoms and exam", "The most likely cardiac condition", "I need to rule out heart disease"]
                     }
                 ];
             } else if (fileNameLower.includes('neuro') || fileNameLower.includes('nervous')) {
                 return [
                     {
                         description: "Neurological History",
                         points: 3,
                         examples: ["Tell me about your headaches", "Any weakness or numbness?", "Have you had any seizures?"]
                     },
                     {
                         description: "Neurological Examination",
                         points: 4,
                         examples: ["I'm going to test your reflexes", "Follow my finger with your eyes", "Can you feel this touch?"]
                     },
                     {
                         description: "Neurological Assessment",
                         points: 3,
                         examples: ["Your nervous system appears", "I need to assess your brain function", "Let's check your coordination"]
                     }
                 ];
             } else if (fileNameLower.includes('resp') || fileNameLower.includes('lung') || fileNameLower.includes('pulm')) {
                 return [
                     {
                         description: "Respiratory History",
                         points: 3,
                         examples: ["Tell me about your breathing", "Any cough or shortness of breath?", "Do you smoke?"]
                     },
                     {
                         description: "Respiratory Examination",
                         points: 4,
                         examples: ["I'm going to listen to your lungs", "Take a deep breath for me", "I'll examine your breathing"]
                     },
                     {
                         description: "Respiratory Assessment",
                         points: 3,
                         examples: ["Your lung sounds indicate", "Based on your breathing pattern", "I need to assess your oxygen levels"]
                     }
                 ];
             } else {
                 // Default medical assessment criteria
                 return [
                     {
                         description: "Patient History Taking",
                         points: 3,
                         examples: ["What brings you in today?", "Tell me about your symptoms", "When did this start?"]
                     },
                     {
                         description: "Physical Examination",
                         points: 4,
                         examples: ["I'm going to examine you now", "Let me check this area", "I'll use my stethoscope"]
                     },
                     {
                         description: "Clinical Assessment & Communication",
                         points: 3,
                         examples: ["Based on my findings", "Here's what I think", "Do you have any questions?"]
                     }
                 ];
             }
         }

         // Create minimal structure for user to customize - with smarter defaults
         function createMinimalRubricStructure(fileName) {
             // Generate smarter criteria based on filename and common medical assessment patterns
             const fileBasedCriteria = generateFileBasedCriteria(fileName);
             
             const basicSection = {
                 name: "Assessment Criteria",
                 code: "AC",
                 maxPoints: fileBasedCriteria.reduce((sum, item) => sum + item.points, 0),
                 items: fileBasedCriteria
             };
             
             return {
                 system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                 user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                 sections: [basicSection],
                 criteria: basicSection.items.map(item => ({
                     name: item.description,
                     max_points: item.points,
                     section: basicSection.name,
                     examples: item.examples
                 })),
                 rubric_analysis: { sections: [basicSection] },
                 assessment_type: 'Editable Template',
                 source_file: fileName,
                 total_points: 10,
                 processing_method: 'Minimal Template for Customization'
             };
         }
        
        // Enhanced section analysis based on file content
        async function enhanceSectionsFromContent(baseSections, extractedText, fileName) {
            const textLower = extractedText.toLowerCase();
            const enhancedSections = [...baseSections];
            
            // Specialty-specific enhancements based on filename and content
            const specialtyPatterns = {
                'cardiology': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to listen to your heart",
                            "Let me check your pulse",
                            "I'll examine your chest now",
                            "Any chest pain when I press here?"
                        ]
                    }
                },
                'respiratory': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to listen to your lungs",
                            "Take a deep breath for me",
                            "I'll examine your breathing",
                            "Any shortness of breath?"
                        ]
                    }
                },
                'neurology': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to test your reflexes",
                            "Follow my finger with your eyes",
                            "Can you feel this touch?",
                            "Try to resist my movement"
                        ]
                    }
                },
                'abdomen': {
                    'Physical Examination': {
                        examples: [
                            "I'm going to examine your abdomen",
                            "Let me feel for any tenderness",
                            "I'll listen to your bowel sounds",
                            "Any pain when I press here?"
                        ]
                    }
                }
            };
            
            // Check for specialty indicators
            for (const [specialty, enhancements] of Object.entries(specialtyPatterns)) {
                if (textLower.includes(specialty) || fileName.toLowerCase().includes(specialty)) {
                    for (const [sectionName, updates] of Object.entries(enhancements)) {
                        const section = enhancedSections.find(s => s.name === sectionName);
                        if (section && updates.examples) {
                            section.examples = [...section.examples, ...updates.examples];
                        }
                    }
                    break;
                }
            }
            
            return enhancedSections;
        }
        
        // Generate a fallback rubric structure when backend is not available (legacy)
        function generateFallbackRubric(fileName) {
            const baseName = fileName.replace(/\.[^/.]+$/, "");
            
            // Create realistic medical criteria based on filename or default
            const criteria = [
                {
                    name: "History Taking",
                    max_points: 3,
                    examples: [
                        "Can you tell me about your symptoms?",
                        "When did this start?",
                        "On a scale of 1-10, how would you rate your discomfort?"
                    ]
                },
                {
                    name: "Physical Examination",
                    max_points: 2,
                    examples: [
                        "I'm going to examine you now",
                        "Let me check this area", 
                        "I'll be using my stethoscope"
                    ]
                },
                {
                    name: "Diagnostic Accuracy/Reasoning/Justification",
                    max_points: 2,
                    examples: [
                        "Based on what you've told me and my examination findings",
                        "The most likely explanation for your symptoms is",
                        "I want to consider a few different possibilities"
                    ]
                },
                {
                    name: "Management",
                    max_points: 2,
                    examples: [
                        "I recommend we start with this treatment approach",
                        "Here's what I think we should do next",
                        "Let me explain your treatment options"
                    ]
                }
            ];
            
            return {
                system_message: "You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.",
                user_message_preamble: "Analyze the following medical examination and provide scores for each criterion:",
                criteria: criteria,
                rubric_analysis: {
                    sections: criteria.map((criterion, index) => ({
                        name: criterion.name,
                        maxPoints: criterion.max_points,
                        items: criterion.examples.map((example, exIndex) => ({
                            description: example,
                            points: 1,
                            examples: [`Example for ${example}`, `Assessment of ${example.toLowerCase()}`]
                        }))
                    }))
                }
            };
        }

        let currentRubricData = null;

        function showDashboard(parsedData) {
            console.log('Processing complete, ready for download:', parsedData);
            
            // Hide processing section
            const processingSection = document.getElementById('processingSection');
            if (processingSection) {
                processingSection.style.display = 'none';
            }
            
            // Show simple download interface instead of complex editor
            showDownloadInterface(parsedData);
        }
        
        function showDownloadInterface(data) {
            console.log('showDownloadInterface called with:', data);
            console.log('window.yamlContent available:', !!window.yamlContent);
            console.log('window.yamlContent length:', window.yamlContent?.length || 0);
            console.log('data.yaml_content available:', !!(data?.yaml_content));
            console.log('data.yaml_content length:', data?.yaml_content?.length || 0);
            
            // Ensure we have YAML content - prioritize data over window
            if (data?.yaml_content) {
                window.yamlContent = data.yaml_content;
                console.log('✅ Set window.yamlContent from data:', window.yamlContent.length, 'characters');
            }
            if (data?.filename) {
                window.originalFileName = data.filename;
                console.log('✅ Set window.originalFileName from data:', window.originalFileName);
            }
            
            // Final check
            const finalYamlContent = window.yamlContent || data?.yaml_content || '';
            const finalFileName = window.originalFileName || data?.filename || 'rubric.yaml';
            
            console.log('🔍 Final YAML content length:', finalYamlContent.length);
            console.log('🔍 Final filename:', finalFileName);
            
            // Extra debugging
            if (finalYamlContent.length === 0) {
                console.log('❌ CRITICAL: Final YAML content is empty!');
                console.log('   - window.yamlContent:', window.yamlContent?.length || 0);
                console.log('   - data.yaml_content:', data?.yaml_content?.length || 0);
                console.log('   - Raw data object:', data);
            } else {
                console.log('✅ Final YAML content first 100 chars:', finalYamlContent.substring(0, 100));
            }
            
            // Get or create download section
            let downloadSection = document.getElementById('downloadSection');
            if (!downloadSection) {
                downloadSection = document.createElement('div');
                downloadSection.id = 'downloadSection';
                downloadSection.className = 'download-card';
                
                // Insert after processing section
                const processingSection = document.getElementById('processingSection');
                processingSection.parentNode.insertBefore(downloadSection, processingSection.nextSibling);
            }
            
            downloadSection.innerHTML = `
                <div class="download-content">
                    <div class="download-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M5 13l4 4L19 7"></path>
                        </svg>
                    </div>
                    <h2 class="download-title">Rubric Processed Successfully!</h2>
                    <p class="download-description">Your rubric has been converted to YAML format and is ready for download.</p>
                    <p class="download-stats">✅ YAML Size: ${finalYamlContent.length} characters | 📊 File: ${finalFileName}</p>
                    
                    <div class="yaml-preview">
                        <h3>YAML Preview:</h3>
                        <pre class="yaml-content">${finalYamlContent.length > 0 ? finalYamlContent.substring(0, 500) + (finalYamlContent.length > 500 ? '\n\n... (truncated for preview)' : '') : 'No YAML content available'}</pre>
                    </div>
                    
                    <div class="download-actions">
                        <button class="download-yaml-button" onclick="downloadYAMLFile()">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Download YAML
                        </button>
                        <button class="process-another-button" onclick="startOver()">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
                                <path d="M21 3v5h-5"></path>
                                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
                                <path d="M3 21v-5h5"></path>
                            </svg>
                            Process Another
                        </button>
                        <button class="test-backend-button" onclick="testBackendConnection()" style="margin-left: 10px; background: #6366f1;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M12 1v6m0 6v6"></path>
                                <path d="m21 12-6-3.46v6.92z"></path>
                                <path d="m3 12 6-3.46v6.92z"></path>
                            </svg>
                            Test Backend
                        </button>
                        <button class="test-direct-button" onclick="testDirectUpload()" style="margin-left: 10px; background: #10b981;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Direct Test
                        </button>
                    </div>
                </div>
            `;
            
            downloadSection.style.display = 'block';
            downloadSection.classList.add('visible');
            
            // Smooth scroll to download section
            setTimeout(() => {
                downloadSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }, 300);
        }

        // Extract and normalize criteria from different data structures
        function extractAndNormalizeCriteria(parsedData) {
            let criteria = [];
            
            // Try to extract from rubric_analysis.sections first (most detailed)
            if (parsedData.rubric_analysis && parsedData.rubric_analysis.sections) {
                parsedData.rubric_analysis.sections.forEach(section => {
                    if (section.items && section.items.length > 0) {
                        section.items.forEach(item => {
                            criteria.push({
                                name: item.description || item.name || 'Assessment Criterion',
                                points: item.points || 1,
                                examples: item.examples || ['Assessment criteria']
                            });
                        });
                    }
                });
            }
            // Try to extract from flat criteria array
            else if (parsedData.criteria && parsedData.criteria.length > 0) {
                criteria = parsedData.criteria.map(criterion => ({
                    name: criterion.name || criterion.description || 'Assessment Criterion',
                    points: criterion.max_points || criterion.points || 1,
                    examples: criterion.examples || ['Assessment criteria']
                }));
            }
            // Try to extract from rubric structure (backend format)
            else if (parsedData.rubric && parsedData.rubric.criteria) {
                criteria = parsedData.rubric.criteria.map(criterion => ({
                    name: criterion.name || criterion.description || 'Assessment Criterion',
                    points: criterion.points || 1,
                    examples: criterion.examples || ['Assessment criteria']
                }));
            }
            
            // If no criteria found, create default medical assessment criteria
            if (criteria.length === 0) {
                criteria = [
                    {
                        name: "History Taking",
                        points: 6,
                        examples: ["Tell me about your symptoms", "When did this start?", "Any family history?"]
                    },
                    {
                        name: "Physical Examination",
                        points: 8,
                        examples: ["I'm going to examine you now", "Let me check this area", "Does this hurt?"]
                    },
                    {
                        name: "Communication Skills",
                        points: 4,
                        examples: ["Do you have any questions?", "Let me explain what I found", "I want to make sure you understand"]
                    },
                    {
                        name: "Professional Behavior",
                        points: 2,
                        examples: ["I'll wash my hands before examining", "Thank you for your cooperation", "Your privacy is important"]
                    }
                ];
            }
            
            // Update the stored data with normalized criteria
            if (!window.currentRubricData.criteria) {
                window.currentRubricData.criteria = criteria;
            }
            
            return criteria;
        }

        // Display criteria with clean, simple structure
        function displayCriteriaClean(criteria, container) {
            criteria.forEach((criterion, index) => {
                const criterionDiv = document.createElement('div');
                criterionDiv.className = 'criterion-item-clean';
                criterionDiv.innerHTML = `
                    <div class="criterion-header-clean">
                        <div class="criterion-number-clean">${index + 1}.</div>
                        <input type="text" class="criterion-name-clean" value="${criterion.name}" 
                               onchange="updateCriterionClean(${index}, 'name', this.value)">
                        <div class="criterion-points-clean">
                            <label>Points:</label>
                            <input type="number" class="points-input-clean" value="${criterion.points}" min="1" max="20" 
                                   onchange="updateCriterionClean(${index}, 'points', this.value)">
                            <button class="remove-criterion-btn-clean" onclick="removeCriterionClean(${index})">Remove</button>
                        </div>
                    </div>
                    <div class="examples-section-clean">
                        <label>Verbalization Examples:</label>
                        <div class="examples-list-clean">
                            ${criterion.examples.map((example, exIndex) => `
                                <div class="example-item-clean">
                                    <input type="text" class="example-input-clean" value="${example}" 
                                           onchange="updateExampleClean(${index}, ${exIndex}, this.value)">
                                    <button class="remove-example-btn-clean" onclick="removeExampleClean(${index}, ${exIndex})">×</button>
                                </div>
                            `).join('')}
                        </div>
                        <button class="add-example-btn-clean" onclick="addExampleClean(${index})">+ Add Example</button>
                    </div>
                `;
                container.appendChild(criterionDiv);
            });
        }

        function displayRubricSections(sections, container) {
            sections.forEach((section, sectionIndex) => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'criterion-section';
                sectionDiv.innerHTML = `
                    <div class="section-header">
                        <div class="section-title-container">
                            <h3 class="section-title non-editable">${section.name}</h3>
                        <div class="section-points">
                            <label>Section Total:</label>
                                <input type="number" class="section-total-input" value="${section.maxPoints}" min="1" max="50" onchange="updateSectionTotal(${sectionIndex})">
                            <span>points</span>
                            </div>
                        </div>
                        <button class="remove-section-btn" onclick="removeSection(${sectionIndex})">Remove Section</button>
                    </div>
                    <div class="criteria-list" id="criteria-${sectionIndex}">
                        ${section.items.map((item, itemIndex) => createCriterionHTML(item, sectionIndex, itemIndex)).join('')}
                    </div>
                    <button class="add-criterion-btn" onclick="addNewCriterion(${sectionIndex})">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Add Item
                    </button>
                `;
                container.appendChild(sectionDiv);
            });
        }

        // Display criteria when we have a flat criteria array (no sections)
        function displayCriteria(criteria, container) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'criterion-section';
            
            // Create a default section for criteria
            const totalPoints = criteria.reduce((sum, criterion) => sum + (criterion.max_points || criterion.points || 0), 0);
            
            sectionDiv.innerHTML = `
                <div class="section-header">
                    <div class="section-title-container">
                        <h3 class="section-title non-editable">Assessment Criteria</h3>
                        <div class="section-points">
                            <label>Section Total:</label>
                            <input type="number" class="section-total-input" value="${totalPoints}" min="1" max="50" readonly>
                            <span>points</span>
                        </div>
                    </div>
                </div>
                <div class="criteria-list" id="criteria-0">
                    ${criteria.map((criterion, index) => createSimpleCriterionHTML(criterion, index)).join('')}
                </div>
                <button class="add-criterion-btn" onclick="addNewCriterion(0)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    Add Criterion
                </button>
            `;
            container.appendChild(sectionDiv);
        }

        // Create HTML for simple criteria (flat structure)
        function createSimpleCriterionHTML(criterion, criterionIndex) {
            const points = criterion.max_points || criterion.points || 1;
            const name = criterion.name || criterion.description || 'New Criterion';
            const examples = criterion.examples || ['Example assessment criteria'];
            
            return `
                <div class="criterion-item" data-section="0" data-criterion="${criterionIndex}">
                    <div class="criterion-header">
                        <div class="criterion-number">${criterionIndex + 1}.</div>
                        <input type="text" class="criterion-name" value="${name}" 
                               onchange="updateSimpleCriterion(${criterionIndex}, 'name', this.value)">
                        <div class="criterion-points">
                            <label>Points:</label>
                            <input type="number" class="points-input" value="${points}" min="1" max="20" 
                                   onchange="updateSimpleCriterion(${criterionIndex}, 'points', this.value)">
                            <button class="remove-criterion-btn" onclick="removeSimpleCriterion(${criterionIndex})">×</button>
                        </div>
                    </div>
                    <div class="examples-section">
                        <label>Examples/Criteria:</label>
                        <div class="examples-list">
                            ${examples.map((example, exIndex) => `
                                <div class="example-item">
                                    <input type="text" class="example-input" value="${example}" 
                                           onchange="updateSimpleExample(${criterionIndex}, ${exIndex}, this.value)">
                                    <button class="remove-example-btn" onclick="removeSimpleExample(${criterionIndex}, ${exIndex})">×</button>
                                </div>
                            `).join('')}
                        </div>
                        <button class="add-example-btn" onclick="addNewSimpleExample(${criterionIndex})">+ Add Example</button>
                    </div>
                </div>
            `;
        }

        function createCriterionHTML(criterion, sectionIndex, criterionIndex) {
            return `
                <div class="criterion-item" data-section="${sectionIndex}" data-criterion="${criterionIndex}">
                    <div class="criterion-header">
                        <div class="criterion-number">${criterionIndex + 1}.</div>
                        <input type="text" class="criterion-name" value="${criterion.description || criterion.name}" 
                               onchange="updateCriterion(${sectionIndex}, ${criterionIndex}, 'name', this.value)">
                        <div class="criterion-points">
                            <label>Points:</label>
                            <input type="number" class="points-input" value="${criterion.points}" min="1" max="20" 
                                   onchange="updateCriterion(${sectionIndex}, ${criterionIndex}, 'points', this.value)">
                            <button class="remove-criterion-btn" onclick="removeCriterion(${sectionIndex}, ${criterionIndex})">×</button>
                        </div>
                    </div>
                    <div class="examples-section">
                    <label>Examples/Criteria:</label>
                    <div class="examples-list">
                            ${(criterion.examples || []).map((example, exIndex) => `
                            <div class="example-item">
                                    <input type="text" class="example-input" value="${example}" 
                                           onchange="updateExample(${sectionIndex}, ${criterionIndex}, ${exIndex}, this.value)">
                                    <button class="remove-example-btn" onclick="removeExample(${sectionIndex}, ${criterionIndex}, ${exIndex})">×</button>
                            </div>
                        `).join('')}
                    </div>
                        <button class="add-example-btn" onclick="addNewExample(${sectionIndex}, ${criterionIndex})">+ Add Example</button>
                    </div>
                </div>
            `;
        }

        // Update criterion data and sync with preview
        function updateCriterion(sectionIndex, criterionIndex, field, value) {
            if (window.currentRubricData && window.currentRubricData.rubric_analysis) {
                const section = window.currentRubricData.rubric_analysis.sections[sectionIndex];
                if (section && section.items[criterionIndex]) {
                    if (field === 'name') {
                        section.items[criterionIndex].description = value;
                        section.items[criterionIndex].name = value;
                    } else if (field === 'points') {
                        section.items[criterionIndex].points = parseInt(value);
                        updateSectionTotals();
                    }
                    updatePreview();
                }
            }
        }

        // Update example and sync with preview
        function updateExample(sectionIndex, criterionIndex, exampleIndex, value) {
            if (window.currentRubricData && window.currentRubricData.rubric_analysis) {
                const section = window.currentRubricData.rubric_analysis.sections[sectionIndex];
                if (section && section.items[criterionIndex] && section.items[criterionIndex].examples) {
                    section.items[criterionIndex].examples[exampleIndex] = value;
                    updatePreview();
                }
            }
        }

        // Update section totals
        function updateSectionTotals() {
            if (window.currentRubricData && window.currentRubricData.rubric_analysis) {
                window.currentRubricData.rubric_analysis.sections.forEach((section, index) => {
                    const total = section.items.reduce((sum, item) => sum + (item.points || 0), 0);
                    section.maxPoints = total;
                    const input = document.querySelector(`input.section-total-input[onchange*="${index}"]`);
                    if (input) input.value = total;
                });
            }
        }

        // Add new example
        function addNewExample(sectionIndex, criterionIndex) {
            if (window.currentRubricData && window.currentRubricData.rubric_analysis) {
                const section = window.currentRubricData.rubric_analysis.sections[sectionIndex];
                if (section && section.items[criterionIndex]) {
                    if (!section.items[criterionIndex].examples) {
                        section.items[criterionIndex].examples = [];
                    }
                    section.items[criterionIndex].examples.push('New example');
                    
                    // Refresh the section display
                    const criteriaContainer = document.getElementById('criteriaContainer');
                    criteriaContainer.innerHTML = '';
                    displayRubricSections(window.currentRubricData.rubric_analysis.sections, criteriaContainer);
                    updatePreview();
                }
            }
        }

        // Simple criteria management functions
        function updateSimpleCriterion(criterionIndex, field, value) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion) {
                    if (field === 'name') {
                        criterion.name = value;
                    } else if (field === 'points') {
                        criterion.max_points = parseInt(value);
                        criterion.points = parseInt(value);
                    }
                    updatePreview();
                }
            }
        }

        function updateSimpleExample(criterionIndex, exampleIndex, value) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion && criterion.examples) {
                    criterion.examples[exampleIndex] = value;
                    updatePreview();
                }
            }
        }

        function addNewSimpleExample(criterionIndex) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion) {
                    if (!criterion.examples) {
                        criterion.examples = [];
                    }
                    criterion.examples.push('New example');
                    
                    // Refresh the display
                    const criteriaContainer = document.getElementById('criteriaContainer');
                    criteriaContainer.innerHTML = '';
                    displayCriteria(window.currentRubricData.criteria, criteriaContainer);
                    updatePreview();
                }
            }
        }

        function removeSimpleExample(criterionIndex, exampleIndex) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion && criterion.examples) {
                    criterion.examples.splice(exampleIndex, 1);
                    
                    // Refresh the display
                    const criteriaContainer = document.getElementById('criteriaContainer');
                    criteriaContainer.innerHTML = '';
                    displayCriteria(window.currentRubricData.criteria, criteriaContainer);
                    updatePreview();
                }
            }
        }

        // Remove example
        function removeExample(sectionIndex, criterionIndex, exampleIndex) {
            if (window.currentRubricData && window.currentRubricData.rubric_analysis) {
                const section = window.currentRubricData.rubric_analysis.sections[sectionIndex];
                if (section && section.items[criterionIndex] && section.items[criterionIndex].examples) {
                    section.items[criterionIndex].examples.splice(exampleIndex, 1);
                    
                    // Refresh the section display
                    const criteriaContainer = document.getElementById('criteriaContainer');
                    criteriaContainer.innerHTML = '';
                    displayRubricSections(window.currentRubricData.rubric_analysis.sections, criteriaContainer);
                    updatePreview();
                }
            }
        }

        // Clean dashboard management functions
        function updateCriterionClean(index, field, value) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[index];
                if (criterion) {
                    if (field === 'name') {
                        criterion.name = value;
                    } else if (field === 'points') {
                        criterion.points = parseInt(value);
                    }
                    updatePreview();
                }
            }
        }

        function updateExampleClean(criterionIndex, exampleIndex, value) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion && criterion.examples) {
                    criterion.examples[exampleIndex] = value;
                    updatePreview();
                }
            }
        }

        function addExampleClean(criterionIndex) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion) {
                    if (!criterion.examples) {
                        criterion.examples = [];
                    }
                    criterion.examples.push('New example');
                    
                    // Refresh the display
                    const criteriaContainer = document.getElementById('criteriaContainer');
                    criteriaContainer.innerHTML = '';
                    displayCriteriaClean(window.currentRubricData.criteria, criteriaContainer);
                    updatePreview();
                }
            }
        }

        function removeExampleClean(criterionIndex, exampleIndex) {
            if (window.currentRubricData && window.currentRubricData.criteria) {
                const criterion = window.currentRubricData.criteria[criterionIndex];
                if (criterion && criterion.examples && criterion.examples.length > 1) {
                    criterion.examples.splice(exampleIndex, 1);
                    
                    // Refresh the display
                    const criteriaContainer = document.getElementById('criteriaContainer');
                    criteriaContainer.innerHTML = '';
                    displayCriteriaClean(window.currentRubricData.criteria, criteriaContainer);
                    updatePreview();
                }
            }
        }

        function removeCriterionClean(index) {
            if (window.currentRubricData && window.currentRubricData.criteria && window.currentRubricData.criteria.length > 1) {
                window.currentRubricData.criteria.splice(index, 1);
                
                // Refresh the display
                const criteriaContainer = document.getElementById('criteriaContainer');
                criteriaContainer.innerHTML = '';
                displayCriteriaClean(window.currentRubricData.criteria, criteriaContainer);
                updatePreview();
            }
        }

        // Add new criterion function (updated for clean dashboard)
        function addNewCriterion() {
            console.log('Adding new criterion...');
            
            const newCriterion = {
                name: 'New Assessment Criterion',
                points: 2,
                examples: ['Assessment example', 'Evaluation criteria']
            };
            
            if (window.currentRubricData) {
                if (!window.currentRubricData.criteria) {
                    window.currentRubricData.criteria = [];
                }
                
                window.currentRubricData.criteria.push(newCriterion);
                
                // Refresh the criteria display
                const criteriaContainer = document.getElementById('criteriaContainer');
                criteriaContainer.innerHTML = '';
                displayCriteriaClean(window.currentRubricData.criteria, criteriaContainer);
                
                updatePreview();
            }
        }

        // Update preview to sync with dashboard changes
        function updatePreview() {
            if (!window.currentRubricData) return;
            
            // Update YAML content based on current data
            const yamlContent = generateYAMLFromCurrentData();
            
            // Update preview display
            const previewContent = document.querySelector('#yamlPreview code');
            if (previewContent) {
                previewContent.textContent = yamlContent;
            }
            
            // Update user message preview
            updateUserMessagePreview();
            
            // Update total points
            updateTotalPoints();
        }

        // Update the Generated User Message Preview
        function updateUserMessagePreview() {
            const previewElement = document.getElementById('userMessagePreview');
            if (!previewElement || !window.currentRubricData) return;
            
            const data = window.currentRubricData;
            let userMessage = "Your task is to identify and score the following assessment criteria in the medical examination.\n\nAssessment Criteria:\n";
            
            // Use the clean criteria structure
            if (data.criteria && data.criteria.length > 0) {
                data.criteria.forEach(criterion => {
                    userMessage += `• ${criterion.name} (${criterion.points || 1} points): Assess the student's performance\n`;
                });
            } else {
                userMessage = 'No criteria defined yet. Add some criteria to see the preview.';
            }
            
            previewElement.textContent = userMessage;
        }

        // Update total points display
        function updateTotalPoints() {
            const totalPointsElement = document.getElementById('totalPoints');
            if (!totalPointsElement || !window.currentRubricData) return;
            
            const data = window.currentRubricData;
            let totalPoints = 0;
            
            // Use the clean criteria structure
            if (data.criteria && data.criteria.length > 0) {
                totalPoints = data.criteria.reduce((sum, criterion) => sum + (criterion.points || 0), 0);
            }
            
            totalPointsElement.textContent = totalPoints;
        }

        // Generate YAML from current dashboard data
        function generateYAMLFromCurrentData() {
            if (!window.currentRubricData || !window.currentRubricData.criteria) return '';
            
            const data = window.currentRubricData;
            const criteria = data.criteria || [];
            const totalPoints = criteria.reduce((sum, criterion) => sum + (criterion.points || 0), 0);
            
            let yaml = `# OSCE Assessment Rubric
# Generated from Dashboard
# Total Points: ${totalPoints}

system_message: |
  You are a helpful assistant tasked with analyzing and scoring a recorded medical examination between a medical student and a patient. Provide your response in JSON format.

user_message: |
  Your task is to identify and score the following assessment criteria in the medical examination.
  
  Assessment Criteria:
`;

            criteria.forEach(criterion => {
                yaml += `  - ${criterion.name} (${criterion.points || 1} points)\n`;
            });

            yaml += `
response_config:
  structured_output: true
  format: json

assessment_config:
  type: "medical_osce_assessment"
  version: "2.0"
  criteria_count: ${criteria.length}
  total_points: ${totalPoints}

assessment_criteria:
`;

            criteria.forEach((criterion, index) => {
                yaml += `  - id: "criterion_${index + 1}"
    name: "${criterion.name}"
    max_points: ${criterion.points || 1}
    description: "${criterion.name}"
    verbalization_examples:
`;
                (criterion.examples || []).forEach(example => {
                    yaml += `      - "${example}"\n`;
                });
            });

            return yaml;
        }

        // Download YAML using backend API
        async function downloadYAMLFile() {
            const yamlContent = window.yamlContent;
            const fileName = window.originalFileName || 'rubric.yaml';
            
            console.log('🔽 Download attempt - YAML length:', yamlContent?.length || 0);
            console.log('🔽 Download attempt - Filename:', fileName);
            
            if (!yamlContent || yamlContent.length === 0) {
                alert('No YAML content available to download.');
                return;
            }
            
            try {
                // Try using backend download endpoint first
                const backendURL = getBackendURL();
                const response = await fetch(backendURL + '/download', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        yaml_content: yamlContent,
                        filename: fileName
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `${fileName.split('.')[0]}.yaml`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    showStatus('success', `YAML file downloaded successfully!`);
                } else {
                    throw new Error('Backend download failed, using direct download');
                }
            } catch (error) {
                console.error('Backend download error, falling back to direct download:', error);
                
                // Fallback: Direct download without backend
                try {
                    const blob = new Blob([yamlContent], { type: 'text/yaml' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `${fileName.split('.')[0]}.yaml`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    showStatus('success', `YAML file downloaded successfully! (direct download)`);
                } catch (directError) {
                    console.error('Direct download also failed:', directError);
                    showStatus('error', 'Failed to download YAML file');
                }
            }
        }

        // Legacy function for compatibility
        function downloadYAML() {
            downloadYAMLFile();
        }

        // Direct test using exact same method as your successful command
        async function testDirectUpload() {
            console.log('🧪 Testing direct upload (matching your successful command)...');
            
            try {
                // Create FormData exactly like your curl command
                const formData = new FormData();
                
                // We need to use the same file - let's create a file input to get it
                const fileInput = document.querySelector('input[type="file"]');
                if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                    alert('Please select the Excel file first!');
                    return;
                }
                
                const selectedFile = fileInput.files[0];
                formData.append('file', selectedFile);
                
                console.log('📤 Uploading file:', selectedFile.name);
                console.log('📤 File size:', selectedFile.size, 'bytes');
                
                const response = await fetch('http://localhost:5003/upload', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('📥 Response status:', response.status);
                console.log('📥 Response headers:', [...response.headers.entries()]);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('✅ SUCCESS! Response data:', data);
                    console.log('✅ YAML content length:', data.yaml_content?.length || 0);
                    
                    // Store the data globally
                    window.yamlContent = data.yaml_content;
                    window.originalFileName = data.filename;
                    
                    alert(`✅ Direct upload successful!\nYAML Length: ${data.yaml_content?.length || 0}\nFilename: ${data.filename}`);
                    
                    // Show the download interface with this data
                    showDownloadInterface(data);
                } else {
                    const errorText = await response.text();
                    console.error('❌ Response not ok:', errorText);
                    alert('❌ Upload failed: ' + errorText);
                }
            } catch (error) {
                console.error('❌ Direct upload error:', error);
                alert('❌ Direct upload error: ' + error.message);
            }
        }

        // Test backend connection function
        async function testBackendConnection() {
            console.log('🧪 Testing backend connection...');
            
            try {
                // First try the health check endpoint
                const backendURL = getBackendURL();
                console.log('🔍 Testing health endpoint at', backendURL);
                const healthResponse = await fetch(backendURL + '/health', {
                    method: 'GET'
                });
                
                if (healthResponse.ok) {
                    const healthResult = await healthResponse.json();
                    console.log('✅ Health check passed:', healthResult);
                    alert('✅ Backend connection successful!\n' + JSON.stringify(healthResult, null, 2));
                    return;
                }
                
                // If health check fails, try the upload endpoint
                console.log('⚠️ Health check failed, trying upload endpoint...');
                const testFile = new File(['test content'], 'test.txt', { type: 'text/plain' });
                const formData = new FormData();
                formData.append('file', testFile);
                
                const response = await fetch(backendURL + '/upload', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('🔍 Test response status:', response.status);
                console.log('🔍 Test response ok:', response.ok);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('✅ Backend is working!', result);
                    alert('✅ Backend connection successful via upload endpoint!');
                } else {
                    const errorText = await response.text();
                    console.log('❌ Backend error:', errorText);
                    alert('❌ Backend error: ' + errorText);
                }
            } catch (error) {
                console.error('❌ Backend connection failed:', error);
                
                // Provide specific error guidance
                if (error.message.includes('Load failed') || error.message.includes('Failed to fetch')) {
                    alert('❌ Backend connection failed!\n\nPossible solutions:\n1. Make sure backend.py is running: python3 backend.py --server\n2. Check if port 5003 is available\n3. Try refreshing the page\n\nError: ' + error.message);
                } else {
                    alert('❌ Backend connection failed: ' + error.message);
                }
            }
        }

        // Fix start over functionality
        function startOver() {
            // Smooth scroll to top
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
            
            // Wait for scroll to complete, then reload
            setTimeout(() => {
                location.reload();
            }, 500);
        }

        // Enhanced status display function
        function showStatus(type, message, persistent = false) {
            const statusMessages = document.getElementById('statusMessages');
            
            // Create status element
            const statusElement = document.createElement('div');
            statusElement.className = `status-message ${type}`;
            
            // Add appropriate icon based on type
            let icon = '';
            switch(type) {
                case 'processing':
                    icon = '<div class="loading-spinner"></div>';
                    break;
                case 'success':
                    icon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="m9 12 2 2 4-4"/>
                              <circle cx="12" cy="12" r="10"/>
                            </svg>`;
                    break;
                case 'error':
                    icon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <circle cx="12" cy="12" r="10"/>
                              <line x1="15" y1="9" x2="9" y2="15"/>
                              <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>`;
                    break;
            }
            
            statusElement.innerHTML = `${icon}<span>${message}</span>`;
            
            // If not persistent, clear previous non-persistent messages
            if (!persistent) {
                const existingMessages = statusMessages.querySelectorAll('.status-message:not([data-persistent])');
                existingMessages.forEach(msg => msg.remove());
            } else {
                statusElement.setAttribute('data-persistent', 'true');
            }
            
            // Add the new status message
            statusMessages.appendChild(statusElement);
            
            // Add animation class
            statusElement.classList.add('fade-in');
            
            // Auto-remove non-persistent error messages after 5 seconds
            if (type === 'error' && !persistent) {
            setTimeout(() => {
                    if (statusElement.parentNode) {
                        statusElement.remove();
                    }
                }, 5000);
            }
        }

        // Enhanced function to add processing progress steps
        function showProcessingSteps() {
            const statusMessages = document.getElementById('statusMessages');
            
            const progressContainer = document.createElement('div');
            progressContainer.className = 'progress-steps';
            progressContainer.innerHTML = `
                <div class="progress-step completed" id="step-upload">
                    <div class="progress-step-icon">✓</div>
                    <span>File Upload</span>
                </div>
                <div class="progress-step" id="step-extract">
                    <div class="progress-step-icon">2</div>
                    <span>Text Extraction</span>
                </div>
                <div class="progress-step" id="step-analyze">
                    <div class="progress-step-icon">3</div>
                    <span>OSCE Analysis</span>
                </div>
                <div class="progress-step" id="step-complete">
                    <div class="progress-step-icon">4</div>
                    <span>Complete</span>
                </div>
            `;
            
            statusMessages.appendChild(progressContainer);
        }

        // Function to update progress steps
        function updateProgressStep(stepId, state = 'active') {
            const step = document.getElementById(stepId);
            if (step) {
                step.classList.remove('active', 'completed');
                step.classList.add(state);
                
                if (state === 'completed') {
                    const icon = step.querySelector('.progress-step-icon');
                    icon.innerHTML = '✓';
                } else if (state === 'active') {
                    const icon = step.querySelector('.progress-step-icon');
                    // Keep the original number for active state
                    if (stepId === 'step-extract') icon.innerHTML = '2';
                    if (stepId === 'step-analyze') icon.innerHTML = '3';
                    if (stepId === 'step-complete') icon.innerHTML = '4';
                }
            }
        }

        // Event listeners for editor updates
        document.addEventListener('DOMContentLoaded', function() {
            // Listen for changes in form inputs to update preview
            document.addEventListener('input', function(e) {
                if (e.target.matches('#systemMessage')) {
                    updateUserMessagePreview();
                }
            });
        });

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            // Show success message
            showStatus('success', `${filename} downloaded successfully!`);
        }

        // Reset functionality
        function resetUpload() {
            currentFile = null;
            processedData = null;
            
            const contentGrid = document.querySelector('.content-grid');
            
            document.getElementById('fileInput').value = '';
            document.getElementById('filePreview').style.display = 'none';
            document.getElementById('processButton').disabled = true;
            document.getElementById('statusMessages').innerHTML = '';
            document.getElementById('processingSection').classList.remove('visible');
            document.getElementById('dashboardSection').classList.remove('visible');
            
            // Reset footer state to initial
            updateFooterState('initial');
            
            // Reset spacing classes
            contentGrid.classList.remove('file-uploaded', 'processing-active', 'dashboard-visible');
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                resetUpload();
            }
        });
    </script>
</body>
</html> 